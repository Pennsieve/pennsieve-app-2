<link rel="import" href="../../../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../../../bower_components/iron-a11y-keys/iron-a11y-keys.html">
<link rel="import" href="../../shared/vuex-behavior/vuex-behavior.html">
<link rel="import" href="bf-layer-menu-window.html">
<link rel="import" href="./annotation-behavior.html">

<link rel="import" href="../../../../styles/blackfynn/main.html">
<link rel="import" href="../../../../styles/blackfynn/icons.html">

<dom-module id="bf-annotation-group">
  <template>
    <style include="blackfynn-main-styles"></style>
    <style type="text/css">
      :host {
        height: 100%;
        @apply(--layout-horizontal);
        @apply(--layout-center);
        @apply(--layout-flex);
      }

      h3, .bf-input {
        font-size: 12px;
        font-weight: 500;
        line-height: 17px;
        margin: 0;
        @apply(--layout-flex);
      }

      .bf-input {
        border: none;
        border-bottom: solid 1px var(--neuron);
        background: transparent;
        outline: none;
      }

      .visibility {
        margin-right: 10px;
      }

      .visibility[hidden] {
        cursor: default;
        color: #000;
        opacity: 0;
        transition: opacity .15s linear;
      }

      .visibilty, :host(:not([visible])) .visibility[hidden] {
        cursor: pointer;
        opacity: 1;
      }

      iron-icon {
        --iron-icon-width: 20px;
        --iron-icon-height: 20px;
        color: #9B9B9B;
      }

      :host([visible]) .visibility, :host(:not([visible])) .visibility[hidden] {
        display: block !important;
      }

      :host(:not([visible])) iron-icon {
        color: #DADADA;
      }

      iron-icon:hover, iron-icon[focused] {
        color: var(--dopamine);
      }

      .visibility iron-icon:nth-child(2) {
        margin-left: 2px;
      }
    </style>

    <h3 hidden$="[[_titleHidden]]">[[layer.name]]</h3>

    <input
      id="inputLabel"
      class="bf-input"
      hidden$="[[!isEditing]]"
      label="Layer Name"
      on-blur="resetLabel"
      on-focus="preventSlide"
      value$="[[origLabel]]"
      autofocus>

    <div class="visibility">
      <iron-icon class="annotation-control" icon="blackfynn:remove-red-eye" on-tap="toggleLayer"></iron-icon>
      <iron-icon class="annotation-control" icon="blackfynn:more-h" hidden$="[[!canCrudAnnotation]]" on-tap="toggleLayerMenu"></iron-icon>
    </div>

    <iron-a11y-keys
      keys="enter"
      target="[[keyTarget]]"
      on-keys-pressed="saveLayer"></iron-a11y-keys>

    <bf-layer-menu-window
      id="layerWindow"
      layer="[[layer]]"
      active-viewer="[[activeViewer]]"></bf-layer-menu-window>

  </template>

  <script>
    Polymer({
      is: 'bf-annotation-group',

      behaviors: [
        Blackfynn.VuexBehavior,
        BlackfynnAnnotationBehavior
      ],

      properties: {
        canCrudAnnotation: {
          type: Boolean,
          value: false
        },
        /**
         * Target for keyboard functionality
         */
         keyTarget: {
          type: Object,
          value: function() {
            return this.$.inputLabel;
          }
        },
        /**
         * track when layer is being edited
         */
         isEditing: {
          type: Boolean,
          value: false
        },
        /**
         * track when annotation is hovered
         */
         hovering: {
          type: Boolean,
          value: false
        },
        /**
         * track when layer menu is visible
         */
         menuVisible: {
          type: Boolean,
          value: false
        },
        /**
         * track when annotation is visible
         */
         visible: {
          type: Boolean,
          value: true,
          reflectToAttribute: true
        },
        /**
         * determines if user is owner of annotation
         */
         isOwner: {
          type: Boolean,
          value: true // will be converted to computed property once we have the data
        },
        /**
         * current user profile object
         */
         profile: {
          type: Object,
          value: function() {
            return {};
          }
        },
        /**
         * current annotation layer
         */
         layer: {
          type: Object,
          value: function() {
            return {};
          }
        },
        hideTitle: {
          type: Boolean,
          value: false
        },
        _titleHidden: {
          type: Boolean,
          computed: '_computeTitleHidden(isEditing, hideTitle)'
        },
        /**
         * original label value
         */
        origLabel: {
          type: String,
          value: ''
        },
        /**
         * computes when to hide controls
         */
        _controlsHidden: {
          type: Boolean,
          computed: '_computeControlsHidden(hovering, isEditing)'
        }
      },

      listeners: {
        'mouseenter': '_mouseenter',
        'mouseleave': '_mouseleave',
        'rename-layer': '_renameLayer',
        'delete-layer': '_deleteLayer'
      },

      observers: [
        '_watchLayerId(layer.id)'
      ],

      _computeTitleHidden: function(isEditing, hideTitle) {
        return isEditing || hideTitle
      },

      _watchLayerId: function(layerId) {
        if (layerId === 0) {
          this.set('isEditing', true);
          this.async(() => this.$.inputLabel.focus(), 500);
        }
      },

      _computeControlsHidden: function(hovering, isEditing) {
        if (isEditing) {
          return true;
        }
        return !hovering;
      },

      /**
       * prevent accordion from opening
       */
      preventSlide: function() {
        this.fire('prevent-accordion-slide', true);
      },

      /**
       * save layer
       */
      saveLayer: function() {
        const payload = Object.assign(this.layer, {
          name: this.$.inputLabel.value
        });
        if (this.layer.id > 0) {
          // update
          this.activeViewer.updateLayer(payload);
        } else {
          // create
          this.activeViewer.saveNewLayer(payload.label, this.activeViewer.layers);
        }
        this.set('isEditing', false);
      },

      /**
       * rename layer state
       * @param {Object} evt
       */
      _renameLayer: function(evt) {
        this.set('isEditing', true);
      },

      /**
       * remove layer from state
       */
      _deleteLayer: function(evt) {
        this.activeViewer.deleteLayer(evt, {
          layer: this.layer,
        })
      },

      /**
       * reset layer label to original value
       */
      resetLabel: function() {
        const inputLabel = this.$.inputLabel;
        if (this.layer.id === 0) {
          return inputLabel.focus();
        }
        inputLabel.value = this.origLabel;
        this.set('isEditing', false);
      },

      /**
       * update layer state
       * @param {Object} state
       */
      _updateLayerState: function(state) {
        // update state
        this.$store.dispatch('viewer/setAnnotations', state)
        .then(() => {
          this.fire('active-viewer-action', {
            method: 'updateCanvasLayers'
          });
        });
      },

      /**
       * prevent accordion from opening when toggling layer visibility
       */
       toggleLayer: function(allVisible) {
        this.preventSlide();

        const newValue = typeof allVisible === 'boolean' ? allVisible : !this.visible;
        this.set('visible', newValue);

        // update state
        const annLayers = this.vuex.viewer.viewerAnnotations;
        const annId = R.propOr('', 'id', this.layer);
        const activeLayerIndex = R.findIndex(R.propEq('id', annId), annLayers);

        if (activeLayerIndex === -1) {
          return
        }

        const layer = Object.assign(this.layer, {
          visible: this.visible
        });

        annLayers[activeLayerIndex] = layer;

        this._updateLayerState(annLayers);
      },

      /**
       * toggle layer context menu
       */
       toggleLayerMenu: function() {
        this.preventSlide();
        this.$.layerWindow.open();
      },

      /**
       * set hovering to true upon mouseenter event
       */
      _mouseenter: function() {
        this.set('hovering', true);
      },

      /**
       * set hovering to false upon mouseleave event
       */
       _mouseleave: function() {
        this.set('hovering', false);
        this.$.layerWindow.close();
      }
    });
  </script>
</dom-module>
