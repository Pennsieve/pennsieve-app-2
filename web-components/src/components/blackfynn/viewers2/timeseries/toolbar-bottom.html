<link rel="import" href="../../../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../../../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../../../bower_components/iron-input/iron-input.html">

<link rel="import" href="../../../../styles/blackfynn/icons.html">
<link rel="import" href="../../../../styles/blackfynn/main.html">
<link rel="import" href="../../shared/bf-input/bf-input.html">
<link rel="import" href="../../shared/zoom-control-simple.html">
<link rel="import" href="../../shared/value-control.html">
<link rel="import" href="../../shared/bf-logger/bf-logger-behavior.html">
<link rel="import" href="../../shared/vuex-behavior/vuex-behavior.html">
<link rel="import" href="../../shared/bf-viewer-toolbar/bf-viewer-toolbar.html">
<link rel="import" href="bf-timeseries-play-speed/bf-timeseries-play-speed.html">
<link rel="import" href="bf-timeseries-montage-scheme/bf-timeseries-montage-scheme.html">


<dom-module id="bf-viewer-timeseries-toolbar-bottom">
  <template>
    <style include="blackfynn-main-styles"></style>
    <style type="text/css">
      :host {
        border-top: 1px solid var(--cortex);
        display: block;
        min-height: 50px;
        width: 100%;
        @apply(--layout-horizontal);
        --paper-icon-button-ink-color: transparent;
      }

      .zoom-controls {
        @apply(--layout-horizontal);
        @apply(--layout-center);
      }
      .btn-zoom {
        padding: 8px 5px;
      }
      .zoom-reset {
        color: #000;
        font-size: 12px;
        margin-left: 5px;
      }
      .zoom-reset:hover, .zoom-reset:focus {
        color: var(--app-primary-color);
      }

      #zoomTime{
        @apply(--layout-self-center);
      }

      .play-controls-wrap {
        background: rgb(256,256,256);
        background: rgba(230,230,230,0.8);
        bottom: 0;
        position: absolute;
        transform: translateY(100%);
        z-index: 1;
        @apply(--layout-horizontal);
        @apply(--layout-justified);
        @apply(--layout-center);
      }

      .play-controls-wrap paper-button {
        background: none;
      }

      #pageMultDiv {
        margin-right:5px;
      }
      .noselect {
        -webkit-touch-callout: none; /* iOS Safari */
        -webkit-user-select: none; /* Chrome/Safari/Opera */
        -khtml-user-select: none; /* Konqueror */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
            not supported by any browser */
      }
      #zoom2Select, #zoomSelect, #zoomIn, #zoomOut {
        height: 32px;
        width: 32px;
      }
      #playSelect {
        height: 28px;
        width: 26px;
      }
      .controller-btn-page-left,
      .controller-btn-page-right {
        height: 28px;
        width: 28px;
      }

      .dashed-annotation-icon {
        height: 26px;
        width: 31px;
        padding: 0;
        margin-top: 9px;
        margin-left: 5px;
        margin-right: 5px;
      }

      .icon-black {
        color: #000
      }
      .toolbar-section {
        @apply(--layout);
        @apply(--layout-flex-auto);
      }
      .toolbar-section.center {
        @apply(--layout-center-justified);
      }
      .toolbar-section.right {
        @apply(--layout-end-justified);
      }
      #scaleTools {
        padding-left: 8px;
      }
      bf-viewer-toolbar-horizontal {
        width: 100%;
        @apply(--layout-horizontal);
      }
      .select-wrapper {
        border-left: 5px solid var(--orange);
      }
      #montageSelect {
        margin: 0;
        min-width: 200px;
      }
    </style>

    <bf-viewer-toolbar-horizontal>
      <div class="toolbar-section left" slot="left">

          <paper-icon-button
            id="zoom2Select"
            class="viewer-btn grey"
            icon="blackfynn:time-scale"
            selected$="[[zoom2ControlsOpen]]"
            noink
            on-tap="_zoom2Select"></paper-icon-button>
          <paper-tooltip fit-to-visible-bounds="true" for="zoom2Select">Scale viewport</paper-tooltip>

          <bf-shared-zoom-control-simple
            id="zoomTime"
            hidden="[[!zoom2ControlsOpen]]"
            icon1=""
            icon2=""
            icon3=""
            label="Width"
            unit="sec"
            parentfnc="time"
            value="{{durationCtl}}"
            isnumeric="true"
            precision="3"></bf-shared-zoom-control-simple>

        <div id="scaleTools">
          <paper-icon-button
            id="zoomSelect"
            class="viewer-btn grey"
            icon="blackfynn:amplitude"
            selected$="[[zoomControlsOpen]]"
            noink
            on-tap="_zoomSelect"></paper-icon-button>
          <paper-tooltip fit-to-visible-bounds="true" for="zoomSelect">Scale Amplitude</paper-tooltip>
        </div>

        <div class="zoom-controls" hidden={{!zoomControlsOpen}}>
          <paper-icon-button
            class="viewer-btn grey btn-zoom"
            id="zoomIn"
            icon="blackfynn:plus_circle"
            noink
            on-tap="gain_btn2"></paper-icon-button>
          <paper-tooltip fit-to-visible-bounds="true" for="zoomIn">Zoom in</paper-tooltip>

          <paper-icon-button
            class="viewer-btn grey btn-zoom"
            id="zoomOut"
            icon="blackfynn:minus-circle"
            noink
            on-tap="gain_btn1"></paper-icon-button>
          <paper-tooltip fit-to-visible-bounds="true" for="zoomOut">Zoom out</paper-tooltip>

          <a href="#" class="zoom-reset" on-tap="autoScale">Reset Zoom</a>
        </div>
      </div>

      <div class="toolbar-section center" slot="center">
        <div>
          <paper-icon-button
            class="controller-btn-page-left icon-black"
            id="prevPage"
            icon="blackfynn:controller-previous-page"
            noink
            on-tap="_onPageBack"></paper-icon-button>
          <paper-tooltip fit-to-visible-bounds="true" for="prevPage">Page back</paper-tooltip>
        </div>

        <div>
          <paper-icon-button
            class="dashed-annotation-icon icon-black"
            id="prevEvent"
            icon="blackfynn:left-facing-arrow"
            noink
            on-tap="_onAnnBack"></paper-icon-button>
          <paper-tooltip fit-to-visible-bounds="true" for="prevEvent">Previous annotation</paper-tooltip>
        </div>

        <div>
          <paper-icon-button
            id="playSelect"
            class="icon-black"
            icon="[[_iconPlay]]"
            noink
            on-tap="_playSelect"></paper-icon-button>
          <paper-tooltip fit-to-visible-bounds="true" for="playSelect">Play/Pause</paper-tooltip>
        </div>

        <div>
          <paper-icon-button
            class="dashed-annotation-icon icon-black"
            id="nextEvent"
            icon="blackfynn:right-facing-arrow"
            noink
            on-tap="_onAnnNext"></paper-icon-button>
          <paper-tooltip fit-to-visible-bounds="true" for="nextEvent">Next annotation</paper-tooltip>
        </div>

        <div>
          <paper-icon-button
            class="controller-btn-page-right icon-black"
            id="nextPage"
            icon="blackfynn:controller-next-page"
            noink
            on-tap="_onPageForward"></paper-icon-button>
          <paper-tooltip fit-to-visible-bounds="true" for="nextPage">Page forward</paper-tooltip>
        </div>
      </div>

      <div class="toolbar-section right" slot="right">
        <bf-timeseries-montage-scheme
          id="bfTimeSeriesMontageScheme"
          montage-scheme="{{montageScheme}}"></bf-timeseries-montage-scheme>
        <bf-timeseries-play-speed
          speed="{{intervalPageMult}}"
          id="playSpeed"></bf-timeseries-play-speed>
        <paper-tooltip fit-to-visible-bounds="true" for="playSpeed">Playback speed</paper-tooltip>
      </div>
    </bf-viewer-toolbar-horizontal>
  </template>

<script>
  Polymer({

    is: 'bf-viewer-timeseries-toolbar-bottom',

    behaviors: [
      Blackfynn.LoggerBehavior,
      Blackfynn.VuexBehavior
    ],

    properties: {
      layers: {
        type: Object,
        notify: true,
      },
      duration: {
        observer: '_durationChanged'
      },

      durationCtl:{
        notify: true,
        type: Number,
        value: 15
      },
      startTime: {
        notify: true,
        type: Number,
        value: 0
      },
      zoomControlsOpen: {
        type: Boolean,
        value: true
      },
      zoom2ControlsOpen: {
        type: Boolean,
        value: true
      },
      zoomLevels: {
        type: Array,
        value: [0.01, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 8, 10, 15, 20, 30, 60, 120, 180, 240, 300, 600, 1800, 3600, 7200, 10800, 14400, 18000]
      },
      parent: {
        type: Object,
        value: null
      },
      mode: {
        type: String,
        value: 'pan'
      },
      viewer: {
        type: Object,
        value: null
      },
      intervalTimer: {
        type: Number,
        value: null
      },
      intervalPageMult:{
        type: Number,
        value: 1
      },
      intervalPage:{
        computed: 'computeInterval(intervalPageMult, duration)'
      },
      isPlaying:{
        type: Boolean,
        value: false
      },
      intervalPeriod:{
        type: Number,
        value: 150
      },
      _iconPlay: {
        type: String,
        computed: '_computeIconPlay(isPlaying)'
      },
      previousMult: {
        type: Number,
        value: 1
      },
      montageSchemes: {
        type: Object,
        value: function() {
          return {
            'Continuous Default': 'NOT_MONTAGED',
            'Referential Montage': 'REFERENTIAL_VS_CZ',
            'Ant/Post Montage': 'BIPOLAR_ANT_POS',
            'Transverse Montage': 'BIPOLAR_TRANSVERSE'
          }
        }
      },
      montageScheme: {
        type: String,
        value: 'Continuous Default',
        observer: 'montageSelectionChanged'
      }
    },

    listeners: {
      'decrease-duration': 'time_btn1',
      'increase-duration': 'time_btn2'
    },

    /**
     * Watcher for montage scheme value
     * @param {String} val
     * @param {String} oldVal
     */
    montageSelectionChanged: function(val, oldVal) {
      if (!oldVal) {
        return
      }

      const scheme = this.montageSchemes[val]
      this.fire('get-montage-scheme', { montage: scheme })
    },

    /**
     * Reset montage scheme selection
     * @param {Object} val
    */
    resetMontageScheme: function(val) {
      const error = R.propOr('', 'error', val)
      if (error === 'PackageCannotBeMontaged') {
        this.montageScheme = 'Continuous Default'
      }
    },

    _durationChanged: function() {
      this.durationCtl = this.duration / 1e6;
    },
    computeInterval: function(mult, duration) {
        if (mult !== this.previousMult) {
            this.intervalPeriod = Math.max(100, this.intervalPeriod * (mult/this.previousMult));
            this.previousMult = mult;
        }
      return 0.05*mult*duration;
    },
    _computeIconPlay: function(isPlaying) {
      if(isPlaying === true) {
        return 'blackfynn:controller-pause';
      } else {
        return 'blackfynn:controller-play';
      }
    },
    _increaseIntervalPage: function() {
      if (this.intervalPageMult > 0.09) {
        this.intervalPageMult = 0.01 * Math.round(100*Math.min(1, this.intervalPageMult+0.1));
      }else {
        this.intervalPageMult = 0.01 * Math.round(100*Math.min(1, this.intervalPageMult+0.01));
      }
    },
    _decreaseIntervalPage: function() {
      if (this.intervalPageMult > 0.11) {
        this.intervalPageMult = 0.01 * Math.round(100*Math.max(0.01, this.intervalPageMult-0.1));
      } else {
        this.intervalPageMult = 0.01 * Math.round(100*Math.max(0.01, this.intervalPageMult-0.01));
      }
    },
    _zoomSelect: function() {
      this.set('zoomControlsOpen', !this.zoomControlsOpen);
    },
    _zoom2Select: function() {
      this.set('zoom2ControlsOpen', !this.zoom2ControlsOpen);
    },
    _playSelect: function() {
      if(this.isPlaying === false) {
        this.$.playSelect.setAttribute('selected', true);
        this.startPlay();
      } else {
        this.$.playSelect.removeAttribute('selected');
        this.stopPlay();
      }
    },
    startPlay: function() {
      this.isPlaying = true;

      let that = this;
      this.intervalTimerFnc = function() {

        // let r = that.viewer.requestedPages;
        //   if(r.size > 0) {
        //     let viewerEndTime = that.viewer.start + that.viewer.duration + that.viewer.pageSize;
        //     let hasSlowed = false;
        //     r.forEach(function(e, k) {
        //         that.logger(k + ' : ' + viewerEndTime);
        //         if(k < viewerEndTime && !hasSlowed) {
        //             that.logger('slowing down');
        //             that.intervalPeriod = that.intervalPeriod + 30;
        //         }
        //     })

        // } else if(that.intervalPeriod > 100) {
        //     that.logger('speeding up');
        //   that.intervalPeriod = Math.max(100, that.intervalPeriod - 60);
        // }

        this.$emit('setStart', this.start + that.intervalPage)

        // that.viewer.setStart(that.viewer.start + that.intervalPage);
        // that.viewer.renderAll(100);
        that.intervalTimer = setTimeout( that.intervalTimerFnc, that.intervalPeriod);
      }

      this.intervalTimer = setTimeout(this.intervalTimerFnc, this.intervalPeriod);

    },
    stopPlay: function() {
      this.isPlaying = false;
      this.intervalPeriod = 150;
      clearInterval(this.intervalTimer);
    },

    zoomToggle: function() {
      this.zoomControlsOpen = !this.zoomControlsOpen;
      if(this.zoomControlsOpen) {
        this.$.btnZoomToggle.setAttribute('selected', true);
      } else {
        this.$.btnZoomToggle.removeAttribute('selected');
      }
    },
    _openAnnotationLayers: function(e, detail) {
      this.fire('ts_editAnnotationLayers');
    },

    gain_btn1: function() {
      this.parent.setGain(this.viewer.globalZoomMult*0.8)
    },
    gain_btn2: function() {
      this.parent.setGain(this.viewer.globalZoomMult*1.25);
    },
    time_btn1: function() {
      let curDuration = this.viewer.duration / 1e6;
      let nextDuration = curDuration;
      for (let i = 0; i < this.zoomLevels.length; i++) {
        if (this.zoomLevels[i] < curDuration ) {
          nextDuration = this.zoomLevels[i]
        }
      }

      this.viewer.setDuration(nextDuration*1e6);
      // this.viewer.setDuration(this.duration*0.8);
      this.viewer.renderAll(500, false);
    },
    time_btn2: function() {
      let curDuration = this.viewer.duration / 1e6;
      let nextDuration = curDuration;
      for (let i = 0; i < this.zoomLevels.length; i++) {
        if (this.zoomLevels[i]> curDuration ) {
          nextDuration = this.zoomLevels[i];
          break
        }
      }
      this.viewer.setDuration(nextDuration*1e6);
      // this.viewer.setDuration(this.duration*1.25);
      this.viewer.renderAll(500, false);
    },
    time_blur: function(value) {
      this.viewer.setDuration(value * 1e6);
      this.viewer.renderAll(250, false);
    },
    updateTimespan: function(value) {
      this.$.zoomTime.preventChangeEvent = true;
      this.timeSpan = value;
    },
    autoScale: function() {
      this.parent.$.viewer.autoScaleViewData();
      this.parent.$.viewer._renderData();
    },
    onSelectLayer: function(e, details) {
      this.fire('ts-toolbar-layer-select', {value: this.layers[details.item.id]});
    },
    _onPageBack: function() {
      this.viewer.setStart(this.viewer.start - (3*this.viewer.duration)/4);
      this.viewer.renderAll(100, false);
    },
    _onPageForward: function() {
      this.viewer.setStart(this.viewer.start + (3*this.viewer.duration)/4);
      this.viewer.renderAll(100, false);
    },
    _onAnnNext: function() {
      let annPanel = this.viewer.plugins['annotate'].panel;
        const cursorOffset = (this.viewer.cursorLoc - this.viewer.constants['CURSOROFFSET']) * this.viewer.rsPeriod;
        let ann = this.findNextAnnotation(this.viewer.start + cursorOffset);
      if (ann !== undefined) {
        annPanel.selectAnnotation(ann, false);
        this.viewer.setStart(ann.start - cursorOffset);
        this.viewer.renderAll(100, false);
      }
    },
    _onAnnBack: function() {
      let annPanel = this.viewer.plugins['annotate'].panel;
        const cursorOffset = (this.viewer.cursorLoc - this.viewer.constants['CURSOROFFSET']) * this.viewer.rsPeriod;
        let ann = this.findPrevAnnotation(this.viewer.start + cursorOffset);
      annPanel.selectAnnotation(ann, false);
      this.viewer.setStart(ann.start - cursorOffset);
      this.viewer.renderAll(100, false);
    },
    findNextAnnotation: function(curTime) {
        let annLayer = this.$store.getters['viewer/getViewerActiveLayer']();
        const index = this.annIndexOf(annLayer.annotations, curTime, false);

        if (index < annLayer.annotations.length) {
          return annLayer.annotations[index + 1];
        } else {
          return annLayer.annotations[index];
        }
      },
      findPrevAnnotation: function(curTime) {
        let annLayer = this.$store.getters['viewer/getViewerActiveLayer']();
        const index = this.annIndexOf(annLayer.annotations, curTime, true);

        if (index > 0) {
          return annLayer.annotations[index - 1];
        } else {
          return annLayer.annotations[index];
        }
      },
      annIndexOf: function(annArray, val, first, startAtIndex, checkEnd) {
        if (!startAtIndex) {
          startAtIndex = 0;
        }

        let index;
        if (checkEnd) {
          index = this._indexOfEnd(annArray, val, startAtIndex, annArray.length - 1, first);
        } else {
          index = this._indexOfStart(annArray, val, startAtIndex, annArray.length - 1, first);
        }

        if (index === -1) {
          index = 0;
        } else if (index < 0) {
          index = -index - 2;
        }
        return index;
      },
      _indexOfStart: function(annArray, val, min, max, firstIndex) {
        /*
         Return code status:
         Positive number:  first index of the value
         Negative 1 (-1):  belongs before the start of the dataset
         Other negative value:  belongs after (-value - 2)
         */
        if (max < min) {
          let pred;
          if (max >= 0) {
            //return -max - 2;
            pred = max;
          } else {
            //return max;
            pred = -max - 2;
          }
          if (pred === -1) {
            return pred;
          }
          const predVal = annArray[pred].start;
          while (pred >= 0 && annArray[pred].start === predVal) {
            pred--;
          }
          pred++;
          return -pred - 2;
        }

        const mid = parseInt((min + max) / 2);

        if (annArray[mid].start > val) {
          return this._indexOfStart(annArray, val, min, mid - 1, firstIndex);
        } else if (annArray[mid].start < val) {
          return this._indexOfStart(annArray, val, mid + 1, max, firstIndex);
        } else {
          let index = mid;
          if (firstIndex) {
            while (index >= 0 && annArray[index].start === val) {
              index--;
            }
            index++;
          } else {
            while (index < annArray.length && annArray[index].start === val) {
              index++;
            }
            index--;
          }
          return index;
        }
      },
      _indexOfEnd: function(annArray, val, min, max, firstIndex) {
        /*
         Return code status:
         Positive number:  first index of the value
         Negative 1 (-1):  belongs before the start of the dataset
         Other negative value:  belongs after (-value - 2)
         */

        if (max < min) {
          let pred;
          if (max >= 0) {
            //return -max - 2;
            pred = max;
          } else {
            //return max;
            pred = -max - 2;
          }
          if (pred === -1) {
            return pred;
          }
          const predVal = annArray[pred].start + annArray[pred].duration;
          while (pred >= 0 && (annArray[pred].start + annArray[pred].duration) === predVal) {
            pred--;
          }
          pred++;
          return -pred - 2;
        }

        const mid = parseInt((min + max) / 2);

        if ((annArray[mid].start + annArray[mid].duration) > val) {
          return this._indexOfEnd(annArray, val, min, mid - 1, firstIndex);
        } else if ((annArray[mid].start + annArray[mid].duration) < val) {
          return this._indexOfEnd(annArray, val, mid + 1, max, firstIndex);
        } else {
          let index = mid;
          if (firstIndex) {
            while (index >= 0 && (annArray[index].start + annArray[index].duration) === val) {
              index--;
            }
            index++;
          } else {
            while (index < annArray.length && (annArray[index].start + annArray[index].duration) === val) {
              index++;
            }
            index--;
          }

          return index;
        }
      },
    ready: function() {
      this.layers = [];
    },
    attached: function() {
      this.$.zoomTime.parent = this;
      this.$store.watch(state => state.viewer.viewerErrors, this.resetMontageScheme.bind(this))
    },
    detached: function() {
      clearInterval(this.intervalTimer);
    },

  });

  </script>
</dom-module>
