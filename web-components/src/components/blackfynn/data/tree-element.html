<link rel="import" href="../../../../bower_components/polymer/polymer.html">

<link rel="import" href="item-label.html">

<link rel="import" href="../../../styles/blackfynn/icons.html">
<link rel="import" href="../../../styles/blackfynn/main.html">
<link rel="import" href="../../../styles/blackfynn/tree.html">
<link rel="import" href="../shared/filetype-mapper-behavior.html">

<dom-module id="blackfynn-data-tree-element">

  <template>
    <style include="blackfynn-main-styles"></style>
    <style include="blackfynn-tree-styles"></style>
    <style type="text/css">
      :host {
        display: block;
      }
      :host([hidden]){
        display: none;
      }
    </style>

    <!-- Current node -->
    <div class$="[[_cpClassCurrentNode(mydata, selected.*, isConverting, hasError)]]" on-tap="doSelect" on-dblclick="doAction" hidden="[[hideItem]]"
         draggable="true" on-dragstart="dragStart" on-dragover="dragOver" on-dragenter="dragEnter" on-dragleave="dragLeave"
         on-drop="dragDrop" on-contextmenu="openMenu">
      <div class="nameCol" style$="[[_cpStyleName(flexWidth)]]">
        <div class="col" style$="[[_cpStyleNameCol(level)]]">
          <div class="expand-icon">
            <iron-icon class="icon-tree" icon="[[_cpExpandIcon(hideChildren)]]" hidden="[[expandHidden]]" on-tap="toggleChildren"></iron-icon>
          </div>

          <blackfynn-data-item-label id="itemLabel" data="[[mydata]]" is-editing="[[isEditing]]" is-processing="[[isProcessing]]"></blackfynn-data-item-label>

          <iron-icon id="rowMenu" class$="[[_cpClassCol(mydata,'menuCol')]]" icon="blackfynn:more-h" hidden="[[isSearch]]" on-tap="openMenu"></iron-icon>
        </div>
      </div>
      <div class$="[[_cpClassCol(mydata,'pathCol')]]">[[treeDetails]]</div>
    </div>

    <!--Recursive elements for children of current node-->
    <div id="childDiv" class="children" hidden="[[hideChildren]]" >
      <template id="treeElementTemplate" is="dom-repeat" items="{{mydata.children}}" sort="[[sortMethod]]">
        <blackfynn-data-tree-element class="elCh" level="[[_computeLevel(level)]]" mydata="{{item}}" host="[[_computeHost(mydata.name)]]" parent-tree="[[parentTreeEl]]" flexWidth="{{flexWidth}}" selected="{{selected}}" api="[[api]]" user="[[user]]"></blackfynn-data-tree-element>
      </template>
    </div>

    <iron-ajax
      id="ajGetChildren"
      method="GET"
      handle-as="json"
      on-error="ajaxError"
      on-response="_setChildren">
    </iron-ajax>

  </template>


  <script>

    Polymer({
      is: 'blackfynn-data-tree-element',
      properties: {
        host: {
          type: Object
        },
        parentTreeEl: {
          type: Object,
          value: function() {
            return this;
          }
        },
        mydata: {
          type: Object,
          notify: true
        },
        isEditing: {
          type: Boolean,
          value: false
        },
        isSelected: {
          type: Boolean,
          value: false,
          notify: true
        },
        isAdding: {
          type: Boolean,
          value: false
        },
        level: {
          type: Number,
          value: 0
        },
        hideChildren: {
          type: Boolean,
          value: true
        },
        hideItem: {
          type: Boolean,
          value: false
        },
        children: {
          type: Object,
          notify: true
        },
        dragCounter: {
          type: Number,
          value: 0
        },
        oldName: {
          type: String,
          value: ''
        },
        sortMethod: {
          type: String,
          value: 'byName'
        },
        flexWidth: {
          type: Number
        },
        isRealFolder: {
          computed: '_computeIsFolder(mydata)'
        },
        treeDetails: {
          type: String,
          computed: '_computeTreeDetails(mydata.content.*)'
        },
        shouldShowChildren: {
          type: Boolean,
          value: false
        },
        isProcessing: {
          type: Boolean,
          value: false
        },
        expandHidden: {
          type: Boolean,
          computed: '_computeExpandHidden(mydata.children.length,mydata.hasChildren)'
        },
        isConverting: {
          type: Boolean,
          value: false,
          computed: '_computeIsConverting(mydata.content.isConverting)'
        },
        hasError: {
          type: Boolean,
          value: false
        },
        isSearch: {
          type: Boolean,
          value: false
        }
      },
      observers: [
        'watchChildren(mydata.children.length)',
        'watchHasError(mydata.hasError)'
      ],
      listeners: {
        'set-processing': 'setProcessing',
        'stop-editing': 'stopEditing'
      },
      behaviors:[
        Blackfynn.FileTypeMapperBehavior
      ],
      attached: function() {
      },
      _computeIsFolder: function(mydata) {
        if(mydata) {
          if(Object.keys(mydata).length) {
            return mydata.content.type === 'Folder' && mydata.content.packageType === undefined;
          }
        }
      },
      getFlexWidth: function(host) {
        return host.flexWidth;
      },
      dragStart: function(e, details) {
        // Select this item if it is not selected
        if(this.selected.indexOf(this) === -1) {
          this.doSelect();
        }

        if(this.mydata.content.isDefault || this.isSearch) {
          e.preventDefault();
        }
        // Capture originating folder in HOST
        this.host.moveItemSource = this;

        // Set DragData to myData
        const dragData = [];
        for (let i = 0; i < this.selected.length; i++) {
          dragData.push(this.selected[i].mydata);
        }

        // Set drag image
        this.fire('start-drag-item', { e, name: this.mydata.content.name });

        const j = JSON.stringify(dragData);
        e.dataTransfer.setData('dragData', j);
      },
      dragEnter: function(ev, details) {
        if (this.isRealFolder && this.mydata.content.name !== 'Teams') {

          // The counter is used to prevent the "dragOver" clas to be removed when drag enters children of the objct.
          this.dragCounter +=1;
          ev.currentTarget.classList.add('dragOver');
        }
      },
      dragLeave: function(ev, details) {
        if (this.isRealFolder) {
          if (!ev.dataTransfer.getData('dragData') && ev.dataTransfer.types[0] === 'Files') {
            this.fire('set-temp-upload-destination', {
              collection: null
            });
          }

          this.dragCounter -= 1;
          if (this.dragCounter === 0) {
            ev.currentTarget.classList.remove('dragOver');
          }
        }
      },
      dragDrop: function(ev, details) {
        // reset counter for dragEnter/dragLeave
        this.dragCounter = 0;

        // Remove style from dropTarget
        ev.currentTarget.classList.remove('dragOver');

        // Hide drag info
        this.fire('end-drag-item');

        // Return if dragData is empty (when event is called other than dragging within browse)
        if (!ev.dataTransfer.getData('dragData') && ev.dataTransfer.files.length === 0) {
          return;
        }

        // If the user is dropping files to upload
        if (!ev.dataTransfer.getData('dragData') && ev.dataTransfer.types[0] === 'Files') {
          if(this.isRealFolder && this.mydata.content.name !== 'Teams' && !this.state.isUploading) {
            this.fire('set-upload-destination', {collection: this.mydata});
          }

          return;
        }
        // Prevent default action from browser
        ev.preventDefault();
        // Prevent Bubbling to Window
        ev.stopPropagation();

        // Parse data string
        const dragData = JSON.parse(ev.dataTransfer.getData('dragData'));

        // Check for locations where item cannot be dragged into
        let isOK = true;
        if (!this.isRealFolder) {
          isOK = false;
        } else if (this.mydata.content.name === 'Teams') {
          isOK = false;
        }

        // Check each piece of drag data
        for (let i = 0; i < dragData.length; i++) {
          if(this.mydata.content.id === dragData[i].content.id) {
            isOK = false;
          } else if (dragData[i].parent === this.mydata.content.id) {
            isOK = false;
          } else {
            // Check not dragging into child folder
            let curItem = this;
            while(curItem.isRealFolder && curItem.mydata.content.isHome === false && curItem.getAttribute('id') !== 'rootElement') {
              if (curItem.parentTree.mydata.content.id === dragData[i].content.id) {
                isOK = false;
                break;
              }
              curItem = curItem.parentTree;
            }
          }
        }

          // debugger;
        // If no problems, do drop logic
        if(isOK) {
          // // Do server update
          this.fire('moveItem', {
            destination: this.mydata.content.id,
            items: this.selected
          });
        }
      },
      dragOver: function(ev, details) {
        // Called every 120ms when dragging on receiving element
        ev.preventDefault();
        ev.dataTransfer.dropEffect = 'move';

        // If the user is dropping files to upload
        if (this.isRealFolder && !ev.dataTransfer.getData('dragData') && ev.dataTransfer.types[0] === 'Files') {
          this.fire('set-temp-upload-destination', {
            collection: this.mydata
          });
        }

      },

      _cpExpandIcon: function(hideChildren) {
        if (hideChildren) {
          return 'blackfynn:folder-expand';
        } else {
          return 'blackfynn:folder-collapse';
        }
      },

      // Bound to class of current item
      _cpClassCurrentNode: function(me, selected, isConverting, hasError) {
        // Bound to current item class

        let itemClass = ' item';
        if (this._computeIsFolder(me))
          itemClass = ' folder';

        if(selected.base.indexOf(this) !== -1) {
          itemClass += ' focus';
        }

        if(isConverting !== undefined) {
          if(isConverting) {
            itemClass += ' converting';
          }
        }

        if(hasError) {
          itemClass += ' error';
        }

        return 'currentLevel' + itemClass;
      },

      // Bound to Style of all columns of current item
      _cpClassCol: function(item, col) {
        // Bound to columns in current item

        let s = col;
        if (this._computeIsFolder(item)) {
          switch (col) {
            case 'nameCol':
              s += ' leftColFolder';
              break;

            case 'dotsCol':
              s+= 'hDots ';
              break;
            case 'createCol':
              break;
            case 'menuCol':
              s += ' middleColFolder';
              break;
            case 'pathCol':
              s += ' rightColFolder';
              break;
          }
        } else {
          s += ' itemRow';
        }
        return s;
      },
      _cpStyleName: function(flexWidth) {
        return 'flex-basis:' + flexWidth +'px';
      },

      // Bound to Style of first (Name) column of current item
      _cpStyleNameCol: function(level) {
        const offs = (this.level-1) * 22;
        return 'margin-left:' + offs + 'px';
      },

      // Bound to host in children of current item
      _computeHost: function(item) {
        if (this.host) {
          return this.host;
        } else{
          return this;
        }
      },

      // Bound to level of children of current item.
      _computeLevel: function(level) {
        return this.level + 1;
      },

      // Callback for single click on menu button
      openMenu: function(e, details) {
        if(this.isSearch) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();

        // Send event based on contextmenu or tap
        if(e.type === 'tap') {
          e = {
            x: e.detail.x,
            y: e.detail.y
          };
        } else {
          e = {
            x: e.clientX,
            y: e.clientY
          };
        }

        this.fire('openMenu', {event: e, id: this.mydata.content.id, el: this});
      },

      // Callback for single click event on item
      doSelect: function(e) {
        let metaKey = false;


        if(e) {
          if(e.detail.sourceEvent.metaKey && !this.isSearch) {
            metaKey = true;

            // Prevent user for multi selecting default folders
            if(this.mydata.content.isDefault) {
              return;
            }
          }
        }

        if(metaKey) {
          if(this.selected.indexOf(this) === -1) {
            this.setSelect(true, metaKey);
          } else {
            this.setSelect(false, metaKey);
          }
        } else {
          this.setSelect(true, metaKey);
        }
      },

      // User is in editing mode and clicked on the input element. Set focus and prevent event bubbling
      inputClicked: function(e, details) {
        e.stopPropagation();
        e.currentTarget.focus(); //should not be necessary.
      },
      getParentFolder: function() {
        return this.parentNode.parentNode;
      },

      // Called on single click, registers item to be selected with host
      setSelect: function(selected, metaKey = false) {
        this.fire('selectItem', { item: this, selected, metaKey });
      },

      // Method that triggers editing of name
      setEditing: function() {
        this.isEditing = true;
        this.oldName = this.mydata.content.name;
        this.host.editedElement = this;
        this.$.itemLabel.$.editInput.focus();
      },

      // Method that sets editing of Child node
      setChildEditing: function(id) {
        // Remove editing flag
        this.isAdding = false;

        // Search for new element
        const chNodes = Polymer.dom(this.root).querySelectorAll('.elCh');

        for (let i=0; i< chNodes.length; i++) {
          if (chNodes[i].mydata.content.id === id) {
            chNodes[i].setEditing();
            break;
          }
        }
      },

      // Callback for double clicking on item
      doAction: function(e, details) {
        // Do nothing if the file is converting
        if(this.mydata.content.isConverting) {
          return;
        }

        if (!this.isRealFolder) {
          const packageType = this.mydata.content.packageType;
          const viewerType = this.viewerForType(packageType);
          if (viewerType) {
            // Open item
            this.fire('openItem', {item: this.mydata});
          } else {
            // Download item
            this.fire('downloadItem', {item: this});
          }
        } else {
          // Collapse into element
          this.fire('doCollapse', {item: this});
        }
      },

      toggleChildren: function(e, details) {
        // If children are already loaded
        if(this.mydata.children !== undefined && this.mydata.children.length && this.mydata.hasChildren) {
          // Prevent registering as click on item.
          e.stopPropagation();

          // Toggle children on/off
          if (this.hideChildren) {
            this.showChildren();
            // this.host.toggleFolderState(this.mydata.content.id, true);
          } else {
            this.hideChildren = true;
            // this.host.toggleFolderState(this.mydata.content.id, false);
            this.setSelect(false);
          }
        } else {
          this.getChildren();
          this.shouldShowChildren = true;
        }
      },

      // Toggle view to show the children
      showChildren: function(forceReload) {
        if (forceReload === undefined) {
          forceReload = false;
        }
        // this.setChildren(forceReload);
        // this.host.toggleFolderState(this.browseroot.id, true);
        this.hideChildren = false;
        this.setSelect(false);

        // Load grandchildren
        this.prefetchGrandchildren();
      },

      // Requests and sets children of the current item
      _setChildren: function(e, detail) {
        if(detail.status === 200 && detail.response) {
          if(e.detail.response.children !== undefined && e.detail.response.children.length) {
            // Add children to this node
            this.set('mydata.children', detail.response.children);

            // Show the new children
            if(this.shouldShowChildren) {
              this.showChildren(true);
              this.shouldShowChildren = false;
            }

            // Set has children flag
            this.set('mydata.hasChildren', true);
          } else {
            this.fire('toast', {type: 'MESSAGE', msg: `No children found for ${detail.response.content.name}`});

            // Set has children flag
            this.set('mydata.hasChildren', false);
          }
        } else {
          this.fire('toast', {type: 'ERROR'});
        }
      },

      // Call API to load children
      getChildren: function(includePackages = false) {
        let url = `${this.api}/packages/${this.mydata.content.id}?api_key=${this.user}`;
        if(includePackages) {
          // Add parameter to request
          url +='&includePackages=true';
          // Set should show children
          this.set('shouldShowChildren', true);
        }
        this.$.ajGetChildren.url = url;
        this.$.ajGetChildren.generateRequest();
      },

      prefetchGrandchildren: function() {
        const chNodes = Polymer.dom(this.$.childDiv).querySelectorAll('.elCh');
        chNodes.forEach(function(entry) {
          if(entry.mydata.hasChildren && entry.mydata.children !== undefined && entry.mydata.children.length === 0 && entry.mydata.content.packageType === undefined) {
            entry.getChildren();
          }
        });
      },

      // Insert a folder in the current item
      insertFolder: function(newFolder) {
        this.showChildren();
        this.push('children', newFolder);
      },

      // Callback from tree that is fired when user clicks outside of editing box during rename
      stopEditing: function(e, detail) {
        // Prevent bubbling
        if(detail === 'nonbubbling') {
          e.stopPropagation();
        }

        this.isEditing = false;
        this.host.editedElement = null;

        // get new name from input
        const newName = this.$.itemLabel.$.editInput.value;

        // Update Name in mydata
        this.set('mydata.content.name', newName);

        // Call tree method for async actions.
        this.fire('renameItem', {
          el: this,
          body: this.mydata.content
        });
      },

      revertName: function(name) {
        // Update Name in mydata
        this.set('mydata.content.name', this.oldName);
      },

      // Rerenders the list of children and resorts after name change.
      _rerenderChildren: function() {
        this.$.treeElementTemplate.render();

        // Open nodes that were open before the rerender
        const chNodes = Polymer.dom(this.root).querySelectorAll('.elCh');
        chNodes.forEach(function(entry) {
          if (entry.host.isFolderOpen(entry.mydata.content.id)) {
            entry.showChildren(true);
            entry._rerenderChildren();
          } else {
            entry.resetNode();
          }
        });

      },

      // ResetNode recursively removes children from node and descendants
      resetNode: function() {
        const chNodes = Polymer.dom(this.root).querySelectorAll('.elCh');
        chNodes.forEach(function(entry) {
          entry.resetNode();
        });
        this.setSelect(false);
        this.children = null;
        this.hideChildren = true;
      },

      // Sorting method that is used by default.
      byName: function(item1, item2) {
        return item1.content.name.localeCompare(item2.content.name);
      },

      watchChildren: function(children) {
        if(children) {
          this.set('mydata.hasChildren', true);
        }
      },

      _computeExpandHidden: function(children, hasChildren) {
        if(children === 0 || !hasChildren) {
          return true;
        }
      },

      findItembyId: function(id, currentNode) {
        let i;
        let currentChild;
        let result;

        if (id === currentNode.content.id) {
          return currentNode;
        } else {

            // Use a for loop instead of forEach to avoid nested functions
            // Otherwise "return" will not work properly
            for (i = 0; i < currentNode.children.length; i += 1) {
                currentChild = currentNode.children[i];

                // Search in the current child
                result = this.findItembyId(id, currentChild);

                // Return the result if the node has been found
                if (result !== false) {
                    return result;
                }
            }

            // The node has not been found and we have no more options
            return false;
        }
      },

      doAddFolder: function(e) {
        // Create new folder with data from server
        const newFolder = {
          hasChildren: false,
          properties: [],
          children: [],
          parent: this.mydata.content.id,
          content: {
            id: e.id,
            name: e.name,
            isDefault: e.isDefault,
            isHome: e.isHome,
            type: 'Folder'
          }
        };

        // Set adding flag
        this.isAdding = true;

        // Add to children
        this.push('mydata.children', newFolder);

        // Edit the folder name
        this.async(function() {
          this.setChildEditing(e.id);
        });
      },

      ajaxError: function(e, detail) {
        this.fire('ajaxError', { status: detail.request.status });
      },

      _computeTreeDetails: function(changeRecord) {
        if(changeRecord.base) {
          if(changeRecord.base.isConverting) {
            return 'Processing';
          }

          if(changeRecord.base.packageType === undefined) {
            return changeRecord.base.type;
          } else {
            return changeRecord.base.packageType;
          }
        }
      },

      setProcessing: function(processing) {
        this.set('isProcessing', processing);
      },

      _computeIsConverting: function(isConverting) {
        if(isConverting) {
          return true;
        } else {
          return false;
        }
      },

      watchHasError: function(hasError) {
        if(hasError) {
          this.set('hasError', true);
          // Disable has error after 3 seconds
          this.async(function() {
            this.set('mydata.hasError', false);
            this.set('hasError', false);
          }, 3000);
        }
      }


    });

  </script>
</dom-module>
