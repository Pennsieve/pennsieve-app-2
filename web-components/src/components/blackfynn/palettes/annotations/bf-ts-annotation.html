<link rel="import" href="../../../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../../../bower_components/iron-flex-layout/iron-flex-layout.html">

<link rel="import" href="./bf-annotation-menu-window.html">
<link rel="import" href="./annotation-behavior.html">
<link rel="import" href="../../shared/vuex-behavior/vuex-behavior.html">
<link rel="import" href="../../shared/item-icon-behavior.html">

<link rel="import" href="../../../../styles/blackfynn/main.html">
<link rel="import" href="../../../../styles/blackfynn/icons.html">
<link rel="import" href="../../../../styles/blackfynn/data-item.html">
<link rel="import" href="../../../../vendor-scripts.html">

<dom-module id="bf-ts-annotation">
  <template>
    <style include="blackfynn-main-styles"></style>
    <style include="bf-data-item-styles"></style>
    <style type="text/css">
      :host {
        display: block;
        overflow: visible;
        position: relative;

        --iron-icon-height: 18px;
        --iron-icon-width: 18px;
      }

      h3 {
        color: #000000;
	      font-size: 13px;
	      font-weight: 500;
	      line-height: 18px;
        margin: 0 0 2px 0;
      }

      .annotation {
        background: #F7F7F7;
        border-bottom: solid 1px #DADADA;
        box-sizing: border-box;
        color: #aeaeae;
        font-size: 12px;
        font-weight: 300;
        min-height: 62px;
        line-height: 14px;
        padding: 8px 10px 8px 15px;
        transition: background .15s linear;
        width: 100%;

        @apply(--layout-vertical);
        @apply(--layout-center-justified);
      }

      .annotation:hover,
      .annotation.active,
      .annotation:focus,
      :host([selected]) .annotation {
        background: #fff;
      }

      .annotation-controls {
        text-align: right;
        max-width: 60px;
        opacity: 0;
      }

      .row {
        @apply(--layout-horizontal);
      }

      .row .col-left {
        @apply(--layout-flex);
      }

      :host([hovering]) .annotation-controls,
      :host([selected]) .annotation-controls {
        opacity: 1;
      }

      .annotation-control {
        transition: color .15s linear;
      }

      .annotation-control:hover {
        cursor: pointer;
      }

      iron-icon {
        color: #000;
      }

      iron-icon:hover, iron-icon[focused] {
        color: var(--dopamine);
      }

      .all-hidden {
        color: #9B9B9B;
      }

      .annotation-controls > p > iron-icon:nth-child(2) {
        margin-left: 2px;
      }

      .description {
        margin: 5px 0px;
        color: #404040;
      }

      .icon-wrap {
        align-self: center;
        display: inline-flex;
        margin-right: 4px;
      }

      .icon-item {
        margin-right: 8px;
      }

      .package-name {
        align-items: center;
        cursor: pointer;
        color: var(--dopamine);
        display: flex;
      }

      .link {
        text-decoration: none;
      }
    </style>

    <div class="annotation" id="[[annotation.id]]">
      <div class="row">
        <h3 class="col-left">[[annotationTitle]]</h3>
        <div class="col-right">[[ layer.name ]]</div>
      </div>
      <div class="row">
        <div class="col-left">
          <div> [[startTime]]</div>
          <div>[[userDisplayName]]</div>
          <div class="description">[[annotationDescription]]</div>
        </div>
        <div class="col-right annotation-controls">
          <iron-icon class="annotation-control" icon="blackfynn:comments" on-tap="viewDiscussion"></iron-icon>
          <iron-icon class="annotation-control" icon="blackfynn:more-h" on-tap="openAnnotationMenu"></iron-icon>
        </div>
      </div>
      <template is="dom-if" if="[[hasLinkedPackage]]">
        <div class="row">
          <div class="icon-wrap">
            <img src$="[[_computeIcon(annotation.linkedPackageDTO)]]" alt="icon" class="svg-icon icon-item">
          </div>
          <div class="package-name">
            <a class="link" on-tap="openPackage" href="#">[[annPkgTitle]]</a>
          </div>
        </div>
      </template>
    </div>

      <bf-annotation-menu-window
        id="annotationMenu"
        annotation="[[annotation]]"
        active-viewer="[[vuex.viewer.activeViewer]]"></bf-annotation-menu-window>
  </template>

  <script>
    Polymer({
      is: 'bf-ts-annotation',

      behaviors: [
        Blackfynn.VuexBehavior,
        BlackfynnAnnotationBehavior,
        Blackfynn.ItemIconBehavior
      ],

      properties: {
        /**
        * start time of the annotation
        */
        startTime: {
          type: String,
          computed: '_computeStart(annotation.start)'
        },
        /**
         * duration of annotation; for timeseries data
         */
        duration: {
          type: String,
          computed: '_computeDuration(annotation.duration)'
        },
        /**
         * date annotation created
         */
         annotationDate: {
          type: String,
          computed: '_computeDate(annotation.updatedAt)' // FIXME: updatedAt isn't coming back from API
        },
        /**
         * time annotation created
         */
        annotationTime: {
          type: String,
          computed: '_computeTime(annotation.updatedAt)'
        },
        /**
         * compute annotation creator's full name
         */
         userName: {
          type: String,
          computed: '_computeUser(annotation.userId, vuex.viewerActiveIndex, vuex.viewers)'
        },
        /**
         * compute annotation creator's display name
         */
        userDisplayName: {
          type: String,
          computed: '_computeUserDisplayName(vuex.profile, userName)'
        },
        /**
         * determines if user is owner of annotation
         */
        isOwner: {
          type: Boolean,
          computed: '_computeOwner(vuex.profile.id, annotation.userId)'
        },
        /**
         * annotation title
         */
        annotationTitle: {
          type: String,
          computed: '_tsAnnotationTitle(annotation)'
        },
        /**
         * annotation description
         */
        annotationDescription: {
          type: String,
          computed: '_tsAnnotationDescription(annotation)'
        },
        /**
         * tracks whether or not component is being hovered over
         */
         hovering: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        /**
         * tracks whether or not component is selected
         */
         selected: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        /**
         * current index for annotation
         */
         index: {
          type: Number,
          value: 0
        },
        /**
         * current user profile object
         */
         profile: {
          type: Object,
          value: function() {
            return {};
          }
        },
        /**
         * current annotation object
         */
         annotation: {
          type: Object,
          value: function() {
            return {};
          },
        },
        /**
        * annotation package title
        */
        annPkgTitle: {
          type: String,
          computed: '_computeAnnPkgTitle(annotation.*)'
        },
        /**
        * checks if annotation has a linked package
        */
        hasLinkedPackage: {
          type: Boolean,
          value: false,
          computed: '_computeHasLinkedPackage(annotation.linkedPackage)'
        },
        /**
         * hide discussion button in timeseries viewer
         */
        hideDiscussionBtn: {
          type: Boolean,
          computed: '_computeHideDiscussionBtn(annotation)'
        },
        layer: {
          type: Object,
          value: function() {
            return {}
          }
        }
      },

      observers: [
        '_watchAnnotation(annotation.*, vuex.config.apiUrl, vuex.userToken)'
      ],

      listeners: {
        'mouseenter': '_mouseenter',
        'mouseleave': '_mouseleave'
      },
      /**
      * Observe changes to the annotation object
      * @param {Object} annotation
      * @param {String} apiUrl
      * @param {String} userToken
      */
      _watchAnnotation: function(annotation, apiUrl, userToken) {
        const linkedPackageId = R.pathOr('', ['base', 'linkedPackage'], annotation)
        const linkedPackageDTO = R.pathOr({}, ['base', 'linkedPackageDTO'], annotation)

        if (linkedPackageId && !linkedPackageDTO.content) {
          this.getPkgData(linkedPackageId, apiUrl, userToken)
        } else if (linkedPackageId && linkedPackageDTO.content) {
          if (linkedPackageId !== linkedPackageDTO.content.id) {
            this.getPkgData(linkedPackageId, apiUrl, userToken)
          }
        }
      },
      /**
      * Compute the annotation package title
      * @param {Object} annotation
      */
      _computeAnnPkgTitle: function(annotation) {
        return R.pathOr('', ['base', 'linkedPackageDTO', 'content', 'name'], annotation)
      },
      /**
       * Check if annotation has a linkedPackage
       * @param {String} linkedPackage
       */
      _computeHasLinkedPackage: function(linkedPackage) {
        return linkedPackage ? true : false
      },
      _tsAnnotationTitle: function(ann) {
        return ann.label;
      },
      _tsAnnotationDescription: function(ann) {
        return ann.description;
      },
      _computeStart: function(start) {
        return this.getUTCDateString(start) + ' ' + this.getUTCTimeString(start);
      },
      /**
       * Hide discussion button for Timeseries viewer
       */
      _computeHideDiscussionBtn: function(annotation) {
        // end property will only exist in timeseries annotations
        if (annotation.end) {
          return true
        }
        return false
      },

      /**
       * Computes user's display name
       * @param {Object} profile
       * @param {String} userName
       * @returns {String}
       */
      _computeUserDisplayName(profile, userName) {
        if (userName.trim().length === 0) {
          return 'Unknown User';
        }
        return userName;
      },

      /**
       * Computes layer name
       * @param {String} layerId
       * @param {Array} layers
       * @returns {String}
       */
      _computeLayerName: function(layerId, layers) {
        const annLayers = R.prop('base', layers);
        if (!annLayers || annLayers.length === 0) {
          return;
        }
        const layer = R.find(R.propEq('id', layerId), annLayers);
        return R.propOr('', 'label', layer);
      },

      /**
      * Handle openPackage event
      */
      openPackage: function(e) {
        e.stopPropagation()
        this.$store.dispatch('openViewer', this.annotation.linkedPackageDTO)
      },

      /**
       * Toggles annotation context menu
       */
       openAnnotationMenu: function() {
        this.$.annotationMenu.open();
      },

      /**
       * Add hovering attribute to host on mouseenter
       */
      _mouseenter: function() {
        this.set('hovering', true);
      },

      /**
       * Remove hovering attribute to host on mouseleave
       */
       _mouseleave: function() {
        this.set('hovering', false);
        this.$.annotationMenu.close();
      },

      /**
       * View discussion in discussion palette
       */
      viewDiscussion: function() {
        const discussionId = this.annotation.discussionId;
        if (discussionId) {
          // View discussion in discussion palette
          this.fire('view-discussion', { id: discussionId});
        } else {
          this.fire('start-discussion', { annotationId: this.annotation.id });
        }
      },
      getUTCDateString: function(d) {
          if(d > 0) {
            d = new Date(d/1000);
            return ( d.toDateString() );
          } else {
            return 'unknown';
          }
        },
      getUTCTimeString: function(d) {
          if(d > 0) {
            d = d / 1000;
            d = new Date(d);
            return ( ('0' + d.getUTCHours()).slice(-2) + ':' +
                ('0' + d.getUTCMinutes()).slice(-2) + ':' + ('0' + d.getUTCSeconds()).slice(-2) );
          }
        },

        /**
         * Fetch Package DTO
         * @param {String} pkgId
         * @param {String} apiUrl
         * @param {String} userToken
         */
        getPkgData: function(pkgId, apiUrl, userToken) {
          if (pkgId && apiUrl && userToken) {
            fetch(`${apiUrl}/packages/${pkgId}?api_key=${userToken}`)
              .then((response) => {
                const { status, statusText } = response

                if (status === 200) {
                  return response.json()
                }
                throw new Error(statusText)
              })
              .then(response => this.handleGetPkgDataResponse(response))
              .catch(err => this.fire('ajaxError', err))
          }
        },

        /**
        * Handle response from getPkgData XHR
        * @param {Object} response
        */
        handleGetPkgDataResponse: function(response) {
          const annotation = R.clone(this.annotation)
          annotation.linkedPackage = R.pathOr('', ['content', 'id'], response)
          annotation.linkedPackageDTO = response

          this.$store.dispatch('viewer/updateAnnotation', annotation)
        }
    });
  </script>

</dom-module>
