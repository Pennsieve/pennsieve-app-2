<link rel="import" href="../../../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../../../bower_components/iron-a11y-keys/iron-a11y-keys.html">
<link rel="import" href="../../../../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../../../../bower_components/iron-pages/iron-pages.html">
<link rel="import" href="../../../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<link rel="import" href="timeseries-annotation-behavior.html">
<link rel="import" href="toolbar.html">
<link rel="import" href="toolbar-bottom.html">
<link rel="import" href="annotate-panel.html">
<link rel="import" href="bf-timeseries-scrubber.html">
<link rel="import" href="canvas/viewer.html">
<link rel="import" href="../../shared/bf-ajax-behavior.html">
<link rel="import" href="../../shared/bf-logger/bf-logger-behavior.html">
<link rel="import" href="bf-timeseries-events/bf-timeseries-events.html">
<link rel="import" href="../../data/property-behavior.html">
<link rel="import" href="../../shared/feature-flag-behavior.html">
<link rel="import" href="./bf-timeseries-annotation-window.html">
<link rel="import" href="./attach-package-window.html">
<link rel="import" href="./bf-ts-filter-window.html">
<link rel="import" href="../../shared/bf-layer-window/bf-layer-window.html">
<link rel="import" href="../../shared/bf-layer-delete-window/bf-layer-delete-window.html">
<link rel="import" href="../../palettes/annotations/bf-annotation-delete.html">
<link rel="import" href="../../shared/color-behavior.html">
<link rel="import" href="../../shared/bf-viewer-package-title.html">
<link rel="import" href="../../shared/show-pkg-title-behavior.html">
<link rel="import" href="../../shared/vuex-behavior/vuex-behavior.html">
<link rel="import" href="../active-tool-behavior.html">

<link rel="import" href="../../../../styles/blackfynn/main.html">

<link rel="import" href="../../../../../bower_components/web-socket/web-socket.html">

<script src="../../../../../bower_components/long/dist/long.min.js"></script>
<script src="../../../../../bower_components/bytebuffer/dist/ByteBufferAB.min.js"></script>
<script src="../../../../../bower_components/protobuf/dist/protobuf.min.js"></script>

<dom-module id="bf-viewer-timeseries">

    <!-- Defines the element's style and local DOM -->
    <template>
        <style include="blackfynn-main-styles"></style>
        <style>
            :host {
              background-color: white;
              width: 100%;
            }
            :host, #viewerWrapper, #viewWrap {
              @apply(--layout-vertical);
            }
            .sidePanelWrapper {
                margin-left: 5px;
                margin-right: 5px;
                min-width: 220px;
                position: relative;
            }
            .sidePanelWrapper[hidden]{
                display:none;
            }
            .timeseries-page {
              @apply(--layout-vertical);
              @apply(--layout-flex-auto);
            }
            .viewer-wrap {
              height: calc(100vh - 170px);
              margin-bottom: 8px;
              @apply(--layout-horizontal);
            }
        </style>

        <template is="dom-if" if="[[showPkgTitle]]">
          <bf-viewer-package-title
            is-active="[[isActive]]"
            title="[[data.name]]"></bf-viewer-package-title>
        </template>


        <div id="viewerWrapper" on-mousemove="_onMouseMove">

            <bf-timeseries-scrubber
              id="scrubber"
              summary="{{summary}}"
              viewer="[[viewer]]"
              viewer-is-ready="[[viewerIsReady]]"
              period="{{period}}"
              pkg="[[pkg]]"
              ann-layer-info="[[annLayerInfo]]"
              ann-layers="[[vuex.viewer.viewerAnnotations]]"
              user="[[user]]"
              api="[[api]]"
              data="[[data]]"
              segment-spans="[[segmentSpans]]"></bf-timeseries-scrubber>

            <div id="viewWrap" >
              <iron-pages id="tabs" class="timeseries-page" attr-for-selected="name" selected="[[selectedTab]]">
                <div class="timeseries-page" name="timeseries">
                  <div class="viewer-wrap">
                    <blackfynn-viewer-timeseries-canvas-viewer
                    id="viewer"
                    summary="{{summary}}"
                    data="[[data]]"
                    channel-config="{{channelConfig}}"
                    start="{{start}}"
                    duration="{{duration}}"
                    c-width="{{cWidth}}"
                    c-height="{{cHeight}}"
                    action-mode="{{actionMode}}"
                    web-socket-open="{{webSocketOpen}}"
                    viewer-is-ready="[[viewerIsReady]]"
                    channels-ready="{{channelsReady}}"
                    is-streaming="{{isStreaming}}"
                    selected-tab="[[selectedTab]]">
                    </blackfynn-viewer-timeseries-canvas-viewer>

                    <div id="annotatePanelWrapper" class="sidePanelWrapper" hidden>
                      <blackfynn-viewer-timeseries-annotate-panel
                        id="annotatePanel"
                        api="[[api]]"
                        user="[[user]]"
                        c-height="[[cHeight]]"
                        channel-config="{{channelConfig}}"
                        summary="[[summary]]"
                        data = "[[data]]"
                        is-streaming= "[[isStreaming]]"
                        ann-layer-info="{{annLayerInfo}}"
                        active-layer="{{activeLayer}}"
                        active-viewer="[[activeViewer]]"
                        ann-layers="[[vuex.viewer.viewerAnnotations]]"></blackfynn-viewer-timeseries-annotate-panel>
                    </div>
                  </div>

                  <bf-viewer-timeseries-toolbar-bottom
                    id="toolbarBottom"
                    start="{{start}}"
                    duration="{{duration}}"></bf-viewer-timeseries-toolbar-bottom>
                </div>
                <template is="dom-if" if="[[_hasEvents]]">
                  <div class="timeseries-page" name="events">
                    <bf-timeseries-events
                      id="eventsPanel"
                      class="timeseries-component"
                      ann-layers="[[annLayerInfo]]"
                      viewer-start="[[start]]"
                      viewer-duration="[[duration]]"
                      scrubber-period="[[period]]"
                      user="[[user]]"
                      api="[[api]]"
                      summary="{{summary}}"
                      _viewport-change="{{_viewportChange}}"
                      selected-tab="[[selectedTab]]"></bf-timeseries-events>
                  </div>
                </template>
              </iron-pages>
            </div>
        </div>

        <bf-annotation-delete
          id="annDeleteConfirmation"></bf-annotation-delete>

        <iron-ajax
          auto
          id="getTimeSeriesSummary"
          method="GET"
          url="[[getViewerDataUrl]]"
          content-type="application/json"
          handle-as="json"
          on-response="_handleGetTSSummary"
          on-error="ajaxError">
        </iron-ajax>

        <iron-ajax
          id="getAnnotationAjax"
          method="GET"
          url="[[getAnnDataUrl]]"
          content-type="application/json"
          handle-as="json"
          on-response="_getAnnResponse"
          on-error="ajaxError">
        </iron-ajax>

        <iron-ajax
          id="updateLayerAjax"
          method="PUT"
          content-type="application/json"
          handle-as="json"
          on-response="_updateLayerResponse"
          on-error="ajaxError">
        </iron-ajax>

        <iron-ajax
          id="createLayerAjax"
          method="POST"
          url="[[getLayerUrl]]"
          content-type="application/json"
          handle-as="json"
          on-error="ajaxError">
        </iron-ajax>

        <iron-ajax
          id="deleteLayerAjax"
          method="DELETE"
          content-type="application/json"
          handle-as="json"
          on-error="ajaxError">
        </iron-ajax>

         <iron-ajax
          id="getTSGaps"
          method="GET"
          content-type="application/json"
          handle-as="json"
          on-error="ajaxError">
        </iron-ajax>

        <bf-timeseries-annotation-window
          id="annotationWindow"
          channels="[[vuex.viewer.viewerChannels]]"
          ></bf-timeseries-annotation-window>

        <attach-package-window
          id="selectPackageWindow"
          cur-package="[[data]]"
          active-organization="[[vuex.activeOrganization]]"
          parent-id="[[data.datasetId]]"></attach-package-window>

        <bf-layer-window
          id="layerWindow"
          layers="[[layers]]"></bf-layer-window>

        <bf-layer-delete-window id="layerDeleteWindow"></bf-layer-delete-window>

        <bf-ts-filter-window id="filterWindow"></bf-annotation-window>
    </template>

    <script>
        Polymer({
            is: 'bf-viewer-timeseries',
            properties: {
                defaultSummary: {
                  channels: [],
                  content: {},
                  globalGaps: [],
                  objects: {},
                  parent: {},
                  properties: [],
                  span: {}
                },
                summary:{
                    notify: true,
                    type: Object,
                    value: {
                      channels: [],
                      content: {},
                      globalGaps: [],
                      objects: {},
                      parent: {},
                      properties: [],
                      span: {}
                    }
                },
                getLayerUrl:{
                  computed: '_computeGetLayerUrl(vuex.config.apiUrl, vuex.userToken, summary.content.id)'
                },
                // Start Timestamp of viewer in microseconds
                start: {
                    notify: true,
                    type: Number,
                    value:0
                },
                // Length of data in viewer in microseconds (ignore gaps)
                duration: {
                    notify: true,
                    type: Number,
                    value: 15 * 1e6
                },
                // Width of the viewer in pixels
                cWidth: {
                    notify: true,
                    type: Number,
                    value: 600
                },
                // Height of the viewer in pixels
                cHeight: {
                    notify: true,
                    type: Number,
                    value: 300
                },
                target: {
                    type: Object,
                    value: function() {
                        return this.$.viewer;
                    }
                },
                getViewerDataUrl: {
                    type: String,
                    computed: '_computeGetViewerDataUrl(vuex.config.apiUrl, vuex.userToken, data)'
                },

                viewerDataId: {
                    type: String,
                    value: ''
                },
                channelConfig: {
                    notify:true,
                    type: Array,
                    value: function() {
                      return [];
                    }
                },
                keyEventTarget: {
                    type: Object,
                    value: function() {
                       return this
                   }
               },
               // Boolean that indicates that websocket to streaming server is open.
                webSocketOpen:{
                    notify: true,
                    type: Boolean,
                    value: false
                },
                // Indicates that channels are initiated
                channelsReady:{
                    notify: true,
                    type: Boolean,
                    value: false
                },
               viewerIsReady:{
                    type: Boolean,
                    notify: true,
                    computed: '_computeViewerReady(summary, channelsReady )'
               },
               isStreaming:{
                   notify: true,
                   type: Boolean,
                   value: false
                },
                /**
                The action mode (point, pan, annotate based on left menu)
                */
                actionMode: {
                  type: String,
                  value: 'pan'
                },

                //The current active tab
                selectedTab: {
                  type: String,
                  value: 'timeseries'
                },
                /**
                 * Determed to show or hide the events tab
                 */
                _hasEvents: {
                  type: Boolean,
                  computed: `hasFeature('TimeSeriesEventsFeature', vuex.activeOrganization.organization.features)`
                },
                /**
                 * Detect if the viewport has changed
                 */
                _viewportChange: {
                  type: Boolean,
                  value: false
                },
                /**
                * Global segments for scrubber
                */
                segments: {
                  type: Array,
                  value: function() {
                    return [];
                    }
                },
                /**
                * Global segment spans
                */
                segmentSpans: {
                  notify: true,
                  type: Array,
                  value: function() {
                    return [];
                  }
                }
            },

            behaviors: [
              Blackfynn.TimeseriesAnnotationBehavior,
              Polymer.IronResizableBehavior,
              Blackfynn.AjaxBehavior,
              Blackfynn.PropertyBehavior,
              Blackfynn.LoggerBehavior,
              Blackfynn.FeatureFlag,
              Blackfynn.ColorBehavior,
              Blackfynn.ShowPkgTitleBehavior,
              Blackfynn.VuexBehavior,
              Blackfynn.ActiveToolBehavior
            ],

            listeners: {
              'iron-resize': 'onSizeChange',
              'newactivelayer': '_onActiveLayerSet',
              'tsEvent': '_tsEventListener',
              'viewport-change': '_onViewportChange',
              'annotation-change': '_onAnnotationChange',
              'annotation-selected': '_onAnnotationSelect',
              'tabs.iron-select': 'pageSelected',
              'set-selected-tab': 'setSelectedTab',
              'set-viewer-viewport': 'setViewport',
              'edit-annotation': 'editAnnotation',
              'create-annotation': 'openAnnotationWindow',
              'confirmed-delete-annotation': '_confirmedDeleteAnnotation',
              'create-layer': 'saveNewLayer',
              'edit-layer': 'updateLayer',
              'delete-layer-confirmation': 'deleteLayerConfirmation',
              'delete-layer': 'deleteLayer',
              'get-old-layer': 'getOldLayer',
              'updateCursor': '_updateScrubber',
              'updateFilters': '_updateFilters',
              'open-select-package-window': 'openSelectPackageWindow',
              'reset-annotation-window': 'resetAnnotationWindow',
              'get-scrubber-annotations': 'getScrubberAnnotations',
              'get-montage-scheme': 'fetchMontageScheme'
            },
            _updateScrubber: function(ev) {
              const scrubber = this.$.scrubber;
              scrubber.setCursor(ev.detail);
            },
            _updateFilters: function(ev, details) {
              if (details.selChannels.length > 0) {

                for (let i=0; i<details.selChannels.length; i++) {
                  this.async(() => {
                    this.$.viewer.updateFilter(details.selChannels[i], details.filterType, parseFloat(details.input0), parseFloat(details.input1), details.notch);
                  })
                }

              }

              const filterWindow = this.$.filterWindow;
              filterWindow.$.dialog.close();
            },
            getOldLayer: function(e, oldLayerId) {
              this.async(() => {
                this.$.scrubber.updateLayer(oldLayerId)
              }, 200)
            },
            /**
            * Set start time for selected annotations
            * @param {Number} annStart
            */
            _onAnnotationSelect: function(annStart) {
              this.$.viewer.setStart(annStart - ((this.$.viewer.cursorLoc - this.$.viewer.constants['CURSOROFFSET']) * this.$.viewer.rsPeriod));
              this.$.viewer.renderAll(100)
            },
            /**
             * Handles confirm-delete-annotation event and launches delete confirmation window
             * @param {Object} evt
             */
            confirmDeleteAnnotation: function(evt) {
              const confirmationWin = this.$.annDeleteConfirmation;
              confirmationWin.set('annotation', evt.annotation);
              confirmationWin.set('annotations', evt.annotations);
              confirmationWin.set('selector', evt.selector);
              confirmationWin.$.annDeleteDialog.open();
            },

            /**
             * Handles delete-annotation event
             * @param {Object} evt
             */
            _confirmedDeleteAnnotation: function(evt) {
              const detail = R.propOr({}, 'detail', evt);

              this.$.annotatePanel.deleteAnnotation({
                id: detail.annotation.id,
                layerId: detail.annotation.layer_id,
                annotations: detail.annotations,
                layer: detail.annotation.layer,
                toast: R.propOr(true, 'toast', detail)
              });

              this.$.scrubber.getAnnotations()
            },

            editAnnotation: function(evt, detail) {
              this.$.annotatePanel.annotationUpdated(detail);
              this.$.scrubber.getAnnotations()
              this.closeAnnotationWindow();
            },

            getScrubberAnnotations: function() {
              this.$.scrubber.getAnnotations()
            },

            /**
              * Open annotation window after the annotation has been drawn
              * @param {Object} payload
              */
            openAnnotationWindow: function(payload) {
              const annotationWindow = this.$.annotationWindow;
              annotationWindow.set('annotation', payload.annotation);
              annotationWindow.set('layers', this.vuex.viewer.viewerAnnotations);
              annotationWindow.set('isCreating', payload.isCreating);
              annotationWindow.set('selectedLabelId', payload.selectedLabelId);

              if (payload.isCreating) {
                annotationWindow.set('selectedLayerId', this.$store.getters['viewer/getViewerActiveLayer']());
              } else {
                annotationWindow.set('selectedLayerId', payload.annotation.layer_id);
              }
              annotationWindow.$.dialog.open();
            },

            /**
              * Close annotation window
              */
            closeAnnotationWindow: function() {
              this.$.annotationWindow.$.dialog.close();
            },

            /**
             * Open layer window
             * @param {Object} payload
             */
             openLayerWindow: function(payload) {
              const layerWindow = this.$.layerWindow
              layerWindow.set('isCreating', payload.isCreating)

              if (!payload.isCreating) {
                layerWindow.set('layer', payload.layer)
              } else {
                layerWindow.set('layer', {})
                layerWindow.setColorByIndex(this.vuex.viewer.viewerAnnotations.length % layerWindow.layerColors.length)
              }

              layerWindow.$.dialog.open()
            },

            _computeViewerReady: function(summary, channelsReady) {
                if(channelsReady && Object.keys(this.summary).length > 0) {
                    return true;
                } else {
                    return false;
                }
            },

            _computeGetViewerDataUrl: function(api, user, data) {
                return `${api}/packages/${data.id}?include=true&api_key=${user}`;
            },

            _handleGetTSSummary: function(e, detail) {
                if (detail.response) {
                    const summary = Object.assign({},
                      detail.response,
                      {
                        span: { start: 0, end: 0 },
                        globalGaps: []
                      }
                    );
                    this.set('summary', summary);

                    const channels = detail.response.channels.map(channel => {
                      const { id } = channel.content
                      channel.content.virtualId = `${id}_${name}`
                      return channel
                    })
                    this.$.viewer.initChannels(channels);

                    // Get summary of Gaps for timeseries package
                    let fetchSpan = Math.min(this.$.viewer.constants['SEGMENTSPAN'], (this.summary.span.end - this.summary.span.start));

                    let chIds = [];
                    for (let i=0; i<this.vuex.viewer.viewerChannels.length; i++) {
                        chIds.push(this.vuex.viewer.viewerChannels[i].id)
                    }
                    let message = {'channelFiltersToClear':chIds};
                    this.async(function() {
                      this.$.viewer.cursorLoc = Math.round(this.cWidth/10);
                      this.$.scrubber.setCursor(1/10);
                      this.$.viewer.sendFilterMessage(message);
                      this.$.viewer.resize();
                    }, 50)

                    for (let i=0; i<this.vuex.viewer.viewerChannels.length; i++) {
                      this._requestSegmentSpan(this.vuex.viewer.viewerChannels[i].id,
                        i, this.summary.span.start, (this.summary.span.start + fetchSpan), 0)
                    }
                }
            },
            /*
              @param channel {string} channel-id
              @param channelIdx {int} index of channel in channelConfig
              @param start {long} start page to be requested
              @param end {long} end of page to be requested
              @param ix {int} recursion iteration
            */
            _requestSegmentSpan: function(channel, channelIdx, start, end, ix) {
              const max_recursion = this.$.viewer.constants['MAXRECURSION']

              let gapAjax = this.$.getTSGaps;
              gapAjax.params = {
                'channel': channel,
                'start': start,
                'end': end
              }
              gapAjax.url = `${this.vuex.config.timeSeriesApi}/ts/retrieve/segments?session=${this.vuex.userToken}`;

              gapAjax.generateRequest().completes.then(payload => {

                // Parse response into vector
                let resp = payload.response;
                let vector = new Array(resp.length*2)
                let i = 0;
                for (let j = 0; j < resp.length; j++) {
                  vector[i] = resp[j][0];
                  vector[i+1] = resp[j][1];
                  i = i+2;

                  // append to global
                  const pxStart = Math.floor(((resp[j][0]-this.summary.span.start)/ (this.summary.span.end - this.summary.span.start))*5000);
                  const pxEnd = Math.ceil(((resp[j][1]-this.summary.span.start) / (this.summary.span.end - this.summary.span.start))*5000);
                  // console.log('st: ' + pxStart + '  nd: ' + pxEnd)
                  this.segments.fill(1, pxStart, pxEnd);
                }

                // Find Global spans
                let ii = 0;
                let inSegment = false;
                let startSegment = 0;
                this.segmentSpans = [];
                while (ii < (this.segments.length-1)) {
                  if (!this.segments[ii] && !inSegment) {
                    ii++;
                    continue
                  } else if (!this.segments[ii]) {
                    // create segment
                    this.segmentSpans = this.segmentSpans.concat([startSegment, ii]);
                    inSegment = false;
                  } else if (!inSegment) {
                    startSegment = ii;
                    inSegment = true;
                  }
                  ii++;
                }
                if (inSegment) {
                  this.segmentSpans = this.segmentSpans.concat([startSegment, ii]);
                }
                this.segmentSpans = this.segmentSpans.concat([5000]);

                // remove first value if there is overlap with previous request
                let firstValue = vector[0];
                let chCongig = this.vuex.viewer.viewerChannels[channelIdx];
                if (firstValue < chCongig.dataSegments[chCongig.dataSegments.length-1]) {
                  vector.shift();
                  vector.shift();
                }

                chCongig.dataSegments= chCongig.dataSegments.concat(vector.sort(function(a, b) {return a - b}));

                // If we did not request all segment-spans yet, get next segment or bail when recursion limit.
                let span = end - start;
                if ((start + span) < this.summary.span.end && ix < max_recursion) {
                  this._requestSegmentSpan(channel, channelIdx, end, (end+span), ix + 1);
                } else {
                  this.$.scrubber.renderSegments();
                }

              })
            },
            _onActiveLayerSet: function(e) {
                this.$.scrubber.setActiveLayer(e.detail);
                this.$.viewer.setActiveLayer(e.detail);
                this.$.toolbarBottom.activeLayer = e.detail;
            },
            _onMouseMove: function(e) {
                const elem = e.srcElement ? e.srcElement : e.target
                // Unfocus elements in the viewer if we are moving outside of the viewer.
                if(elem.id !=='viewer') {
                    this.$.viewer.unfocusElements();
                }

            },
            resizeViewer: function() {
                this.$.viewer.resize();
            },
            setMode: function(mode) {
                switch(mode) {
                  case 'pan':
                    this.actionMode = 'pan';
                    break;
                  case 'point':
                    this.actionMode = 'point';
                    break;
                  case 'annotate':
                    this.actionMode = 'annotate';
                    break;
                }
                let that = this.$.viewer;
                for(let i in that.plugins) {
                  if (that.plugins.hasOwnProperty(i)) {
                    that.plugins[i].panel.render();
                  }
                }
            },
            // Update global zoom multiplier
            setGain: function(value) {
                this.$.viewer.globalZoomMult = value;
                this.$.viewer._renderData();
            },

            created: function() {

            },
            attached: function() {
              this.set('summary', this.defaultSummary)
              this.$.viewer.parent = this;

              // Set links to subComponents
              this.$.annotatePanel.parent = this;
              this.$.annotatePanel.viewer = this.$.viewer;
              this.$.scrubber.parent = this;
              this.$.scrubber.viewer = this.$.viewer;

              this.$.toolbarBottom.parent = this;
              this.$.toolbarBottom.viewer = this.$.viewer;

              // Add timeseries plugins
              this.$.viewer.addPlugin(this.$.annotatePanel, 'annotate', true, [this.$.viewer.$.annArea, this.$.viewer.$.annLabelArea] );
              this.$.viewer.addPlugin(this.$.scrubber, 'scrubber', true, null );

              this.segments = new Array(5000);
              this.segments = this.segments.fill(0, 0, 4999);

              this.async(() => {
                  this.$store.dispatch('viewer/setActiveTool', 'pan')
                }, 50);


            },

            // Event listener for annotation callback "on received annotation from web-socket"
            _tsEventListener: function(tsEvents) {
              tsEvents.detail.forEach( (tsEvent) => {
                let startTs = tsEvent.startTs.toNumber();
                let d = tsEvent.duration.toNumber();
                this.$.annotatePanel.addAnnotation(startTs, d);
                })
            },
            // Update viewer size on resize callback
            onSizeChange: function() {
                let w = this.offsetWidth;
                let h = window.innerHeight - 100;
                this.$.viewer.setWindowSize(w, h);
            },

            _onViewportChange: function() {
              this.set('_viewportChange', true);
            },

            _onAnnotationChange: function(e, detail) {
              this.$.scrubber.onLayerChange(detail.layerId, detail.type);
            },

            pageSelected: function(e, detail) {
              const component = Polymer.dom(detail.item).querySelector('.timeseries-component');
              this.fire('selected', {}, { node: component });
            },
            /**
             * Gets channel index from channels list given an id
             * @param {String}
             * @param {Array}
             * @returns {Object}
             */
            _getByIndex: R.useWith(
              R.findIndex, [R.propEq('id')]
            ),

            /**
             * Set channel visibility
             * @param {Object} visible
             */
            toggleAllVisibility: function(visible) {
              const channels = R.clone(this.vuex.viewer.viewerChannels)

              // Set all channels visible property to false
              channels.map(channel => {
                channel.visible = visible
                return channel
              })

              this.$store.dispatch('viewer/setChannels', channels)
              this.$.viewer.renderAll();
            },

            /**
             * Set channel visibility for a group
             * @param {Object} payload
             */
             toggleGroupVisibility: function(payload) {
              const channels = R.clone(this.vuex.viewer.viewerChannels)

              const visible = R.propOr(true, 'visible', payload)
              const channelType = R.propOr(true, 'channelType', payload)

              // Set all channels visible property to false
              channels.map(channel => {
                if (channel.type === channelType) {
                  channel.visible = visible
                }

                return channel
              })

              this.$store.dispatch('viewer/setChannels', channels)
              this.$.viewer.renderAll();
             },

            /**
             * Set's the selected tab
             * @param {Object} Event Object
             * @param {Object} detail
             */
            setSelectedTab: function(e, detail) {
              this.set('selectedTab', detail.tab);
            },

            /**
             * Sets the viewport's start and duration
             * @param {Object} Event Object
             * @param {Object} detail
             */
            setViewport: function(e, detail) {
              const buffer = 30000000;
              const adjustedStart = detail.start - buffer;
              const duration = (detail.end + buffer) - adjustedStart;

              this.$.viewer.setStart(adjustedStart);
              this.$.viewer.setDuration(duration);
            },
            /*
             * Set pan mode
             */
            setPan: function() {
              this.setMode('pan');
            },
            /*
             * Set pointer mode
             */
            setPointer: function() {
              this.setMode('point');
            },
            /*
             * Set annotate mode
             */
            setAnnotate: function() {
              this.setMode('annotate');
            },

            /*
             * Open filter dialog
             * @param {Object} payload
             */
            openFilterWindow: function(payload) {
              const channels = R.propOr([], 'channels', payload);
              const filter = R.propOr('', 'filter', payload);
              const filterWindow = this.$.filterWindow;
              filterWindow.onChannels = channels;

              if (!R.isEmpty(filter)) {
                filterWindow.input0 = filter.input0;
                filterWindow.input1 = filter.input1;

                for (let i=0; i<filterWindow._filters.length; i++) {
                  if (filterWindow._filters[i].value === filter.type) {
                    filterWindow.selectedFilterId = filter.type;
                    break;
                  }
                }

                for (let i=0; i<filterWindow._notchValues.length; i++) {
                  if (filterWindow._notchValues[i].value === filter.notchFreq) {
                    filterWindow.selectedNotchId = filter.notchFreq;
                    break;
                  }
                }
              } else {
                filterWindow.input0 = NaN;
                filterWindow.input1 = NaN;
                filterWindow.selectedFilterId = '';
                filterWindow.selectedNotchId = '';
              }
              filterWindow.$.dialog.open();
            },
            /**
             * Handle open select package window event
             * @param {Object} e
             * @param {Object} annotation
            */
            openSelectPackageWindow: function(e, annotation) {
              const window = this.$.selectPackageWindow
              window.annotation = annotation
              window.openWindow()
            },
            /**
             * Handle reset annotation window event
             */
            resetAnnotationWindow: function() {
              this.$.annotationWindow.reset()
            },
            /**
             * Select channel by ID
             * @param {Object} payload
             */
            selectChannel: function(payload) {
              this.$.viewer.selectChannel(payload.channelId, payload.append);
              this.$.viewer.renderAll();
            },

            /**
             * Call render all function in canvas viewer
            */
            renderAll: function() {
              this.$.viewer.renderAll()
            },

            /**
             * Call initChannels function in canvas viewer
             * @param {Array} channels
             * @returns {Promise}
            */
            initChannels: function(channels) {
              return this.$.viewer.initChannels(channels)
            },

            /**
             * Initialize channels after renaming them in PaletteChannels.vue
             */
            updateChannels: function() {
              const channels = this.vuex.viewer.viewerChannels.map(channel => {
                return {
                  content: {
                    rate: R.propOr(0, 'sf', channel),
                    name: channel.label,
                    channelType: channel.type,
                    id: channel.id,
                    properties: R.pathOr([], [0, 'properties'], channel),
                    end: R.pathOr(0, ['dataSegments', 1], channel),
                    unit: channel.unit,
                    lastAnnotation: R.propOr(0, 'lastAnnotation', channel),
                    start: R.pathOr(0, ['dataSegments', 0], channel)
                  }
                }
              })
              this.initChannels(channels)
                .then(() => {
                  this.invalidateCache = true
                  this.renderAll()
                })
            },

            /**
             * Get montage scheme data
             * @param {Object} evt
            */
            fetchMontageScheme: function(evt) {
              const canvasViewer = this.$.viewer
              canvasViewer.sendMontageMessage(evt.detail)
              // clear cached annotation range for montage
              this.$.annotatePanel.cachedAnnRange = []
            }
        });
    </script>

</dom-module>
