<link rel="import" href="../../../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../../../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../../../../bower_components/paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../../../../../bower_components/paper-button/paper-button.html">

<link rel="import" href="../bf-chart-tooltip/bf-chart-tooltip.html">

<link rel="import" href="../chart-styles.html">
<link rel="import" href="../../../../styles/blackfynn/main.html">
<link href="../plottable.css" media="all" rel="stylesheet">

<script src="../../../../../node_modules/d3/build/d3.min.js"></script>
<script src="../../../../../node_modules/plottable/plottable.js"></script>

<!--
## bf-box-chart

`<bf-box-chart>` is a component to display an individual package.

## Chart table layout

```
|----------------------------|      A: yAxis
|   |                        |      B: intensityPlots
| A |          B             |      C: xAxis
|   |                        |      D: eventPlots
|---|------------------------|
|   |          C             |
|   |------------------------|
|   |                        |
|   |          D             |
|   |                        |
|----------------------------|
```
@demo
-->

<dom-module id="bf-box-chart">

  <template>
    <style include="blackfynn-main-styles"></style>
    <style include="bf-chart-styles"></style>

    <style>
    :host {
      border-bottom: 1px solid #ddd;
      box-sizing: border-box;
      font-family: 'FiraMono', sans-serif;
      min-height: 220px;
      padding: 34px 0 34px 20px;
      position: relative;
      @apply(--layout-horizontal);
      @apply(--layout-end);
    }
    :host(:last-of-type) {
      border-bottom: none;
    }
    #chart {
      overflow: hidden
    }
    .chart-info {
      font-size: 14px;
      text-transform: uppercase;
      width: 200px;
      @apply(--layout-vertical);
    }
    .chart-info .value {
      font-size: 48px;
      font-weight: bold;
      line-height: 1;
    }
    .chart-wrap {
      display: block;
      position: relative;
      height: 153px;
      @apply(--layout-flex);
    }
    .loading-wrap {
      background: rgba(255,255,255,.5);
      height: 100%;
      left: 0;
      position: absolute;
      top: 0;
      width: 100%;
      @apply(--layout-horizontal);
      @apply(--layout-center);
      @apply(--layout-center-justified);
    }
    bf-chart-tooltip {
      pointer-events: none;
    }
    .focus-point .symbol {
      cursor: pointer;
      animation: pulse 3s infinite;
    }

    @keyframes pulse {
      from {
        stroke-opacity: 100%
      }
      50% {
        stroke-opacity: 0
      }
      to {
        stroke-opacity: 100%
      }
    }
    </style>

    <div class="chart-info" hidden$="[[!chartInfo]]">
      <span id="deviceInfo" class="value">[[_entityCount]]</span>
      <span class="category">[[annLayer.name]]</span>
    </div>

    <div class="chart-wrap">
      <div id="chart"></div>

      <bf-chart-tooltip
        id="tooltip"
        hidden$="[[tooltipHidden]]"
        annotation="[[annotation]]"
        position="[[tooltipPosition]]"
        loading="[[loadingTooltip]]"></bf-chart-tooltip>
    </div>

    <div class="loading-wrap" hidden$="[[!isLoading]]">
      <paper-spinner-lite active="[[isLoading]]"></paper-spinner-lite>
    </div>

    <iron-ajax
      id="getAnnotations"
      method="GET"
      handle-as="json"
      loading="{{isLoading}}"
      url="[[_getAnnotationUrl]]"
      content-type="application/json"
      on-response="_handleGetAnnotations"
      on-error="ajaxError"></iron-ajax>

    <iron-ajax
      id="getTooltipAnnotation"
      method="GET"
      handle-as="json"
      loading="{{loadingTooltip}}"
      url="[[_getTooltipAnnotationUrl]]"
      content-type="application/json"
      on-response="_handleGetTooltipAnnotations"></iron-ajax>

  </template>

  <script>

    Polymer({
      is: 'bf-box-chart',

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      properties: {
        /**
         * Chart data
         */
        events: {
          type: Array,
          value: function() {
            return [];
          }
        },
        /**
         * Events dataset for the chart library
         */
        datasetEvents: {
          type: Object,
          value: function() {
            return new Plottable.Dataset();
          }
        },
        /**
         * Dataset for the focus point
         */
        datasetForFocusPoint: {
          type: Object,
          value: function() {
            return new Plottable.Dataset();
          }
        },
        /**
         * Color of plots on chart
         */
        entityColor: {
          type: String,
          value: '#2760FF'
        },
        /**
         * Hover color of plots on chart
         */
        entityColorHover: {
          type: String,
          value: '#071540'
        },
        /**
         * Color of event plots on chart
         */
        eventColor: {
          type: String,
          value: '#dadada'
        },
        /**
         * Scale of the Y Axis
         */
        yScale: {
          type: Object,
          value: function() {
            return new Plottable.Scales.Linear();
          }
        },
        /**
         * Computes the type and location of the Y Axis
         */
        yAxis: {
          type: Object,
          computed: '_computeYAxis(yScale)'
        },
        /**
         * Scale of the X Axis
         */
        xScale: {
          type: Object,
          value: function() {
            return new Plottable.Scales.Time().autoDomain(false);
          }
        },
        /**
         * Computes the type and location of the X Axis
         */
        xAxis: {
          type: Object,
          computed: '_computeXAxis(xScale)'
        },
        /**
         * Scale of the Overview's Y Axis
         */
        overviewYScale: {
          type: Object,
          value: function() {
            return new Plottable.Scales.Category();
          }
        },
        /**
         * Overview plots, located at the top of the chart
         */
        eventPlots: {
          type: Object,
          value: function() {
            return {};
          }
        },
        /**
         * Event plots, located at the bottom of the chart
         */
        intensityPlots: {
          type: Object,
          value: function() {
            return {};
          }
        },
        /**
         * Focus point, small solid circle
         */
        focusPoint: {
          type: Object,
          value: function() {
            return {};
          }
        },
        /**
         * Plottable Table
         */
        chart: {
          type: Object,
          value: function() {
            return {};
          }
        },
        /**
         * Count the total entities in the viewable area
         */
        _entityCount: {
          type: Number,
          value: 0
        },
        /**
         * Category of events. Used for the label on the left
         */
        category: {
          type: String,
          value: 'Events'
        },
        /**
         * Show the chart info
         */
        chartInfo: {
          type: Boolean,
          value: false
        },
        /**
         * Chart interaction for panning and zooming
         */
        panZoomInteraction: {
          type: Object,
          value: function() {
            return {};
          }
        },
        /**
         * Chart interaction for mouse events
         */
        pointerInteraction: {
          type: Object,
          value: function() {
            return {};
          }
        },
        /**
         * Object to track plottable click interaction
         */
        focusPointClick: {
          type: Object,
          value: function() {
            return {};
          }
        },
        /**
          * Computed URL for annotaitons endpoint
          */
        _getAnnotationUrl: {
          type: String,
          computed: '_computeGetAnnotationUrl(api, user, annLayer)'
        },
        /**
          * Computed URL for tooltip annotaitons endpoint
          */
        _getTooltipAnnotationUrl: {
          type: String,
          computed: '_computeGetTooltipAnnotationUrl(api, user, annLayer)'
        },
        /**
          * Annotations are being loaded
          */
        isLoading: {
          type: Boolean,
          value: false
        },
        /**
          * Tooltip annotations are being loaded
          */
        loadingTooltip: {
          type: Boolean,
          value: false
        },
        /**
         * Hide the tooltip
         */
        tooltipHidden: {
          type: Boolean,
          value: true
        },
        /**
         * Position of the tooltip, for styling
         */
        tooltipPosition: {
          type: String,
          value: 'left'
        },
        /**
         * Axis formatting, displaying in 24 hour
         */
        axisConfig: {
          type: Array,
          value: [
              [
                  { interval: Plottable.TimeInterval.second, step: 1, formatter: Plottable.Formatters.time('%H:%M:%S %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.second, step: 5, formatter: Plottable.Formatters.time('%H:%M:%S %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.second, step: 10, formatter: Plottable.Formatters.time('%H:%M:%S %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.second, step: 15, formatter: Plottable.Formatters.time('%H:%M:%S %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.second, step: 30, formatter: Plottable.Formatters.time('%H:%M:%S %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.minute, step: 1, formatter: Plottable.Formatters.time('%H:%M %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.minute, step: 5, formatter: Plottable.Formatters.time('%H:%M %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.minute, step: 10, formatter: Plottable.Formatters.time('%H:%M %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.minute, step: 15, formatter: Plottable.Formatters.time('%H:%M %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.minute, step: 30, formatter: Plottable.Formatters.time('%H:%M %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.hour, step: 1, formatter: Plottable.Formatters.time('%H %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.hour, step: 3, formatter: Plottable.Formatters.time('%H %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.hour, step: 6, formatter: Plottable.Formatters.time('%H %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.hour, step: 12, formatter: Plottable.Formatters.time('%H %p') },
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%B %e, %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%a %e') },
                  { interval: Plottable.TimeInterval.month, step: 1, formatter: Plottable.Formatters.time('%B %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.day, step: 1, formatter: Plottable.Formatters.time('%e') },
                  { interval: Plottable.TimeInterval.month, step: 1, formatter: Plottable.Formatters.time('%B %Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.month, step: 1, formatter: Plottable.Formatters.time('%B') },
                  { interval: Plottable.TimeInterval.year, step: 1, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.month, step: 1, formatter: Plottable.Formatters.time('%b') },
                  { interval: Plottable.TimeInterval.year, step: 1, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.month, step: 3, formatter: Plottable.Formatters.time('%b') },
                  { interval: Plottable.TimeInterval.year, step: 1, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.month, step: 6, formatter: Plottable.Formatters.time('%b') },
                  { interval: Plottable.TimeInterval.year, step: 1, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.year, step: 1, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.year, step: 1, formatter: Plottable.Formatters.time('%y') },
              ],
              [
                  { interval: Plottable.TimeInterval.year, step: 5, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.year, step: 25, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.year, step: 50, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.year, step: 100, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.year, step: 200, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.year, step: 500, formatter: Plottable.Formatters.time('%Y') },
              ],
              [
                  { interval: Plottable.TimeInterval.year, step: 1000, formatter: Plottable.Formatters.time('%Y') },
              ],
          ]
        }
      },

      listeners: {
        'iron-resize': 'onResize',
        'render': '_onRender'
      },

      observers: [
        'watchEvents(events.length)'
      ],

      attached: function() {
        // this.initCharts();
      },

      detached: function() {
        // Destroy the chart
        if(Object.keys(this.chart).length) {
          this.chart.destroy();
        }
        // this.pointerInteraction.detachFrom(this.intensityPlots);
        // this.pointerInteraction.destroy();
      },

      _computeGetAnnotationUrl: function(api, user, annLayer) {
        return `${api}/timeseries/${annLayer.timeSeriesId}/layers/${annLayer.id}/annotations/window`;
      },

      /**
       * Computes annotation url for tooltip
       * @param {String} api base url
       * @param {String} user token
       * @param {Object} annotation layer object
       */
      _computeGetTooltipAnnotationUrl: function(api, user, annLayer) {
        return `${api}/timeseries/${annLayer.timeSeriesId}/layers/${annLayer.id}/annotations`;
      },

      watchEvents: function(eventsLength) {
        if(eventsLength) {
          const dataset = this.get('datasetEvents');
          dataset.data(this.events);

          // Update chart info if the charts are loaded
          if(Object.keys(this.chart).length) {
            this.updateInfo();
          }
        }
      },

      /*
       * Render charts when the user activates the events tab
       * This is due to a rendering issue with display: none and the x-axis
       */
      _onRender: function() {
        if(Object.keys(this.chart).length === 0) {
          this.initCharts();
        }
      },

      initCharts: function() {
        this.xAxis.axisConfigurations(this.axisConfig);
        // Intensity plots
        this.intensityPlots = new Plottable.Plots.Area()
          .x((d) => { return this._getUTCDate(d.start); }, this.get('xScale'))
          .y(function(d) { return d.value; }, this.get('yScale'))
          .attr('fill', this.get('entityColor'))
          .attr('stroke', this.get('entityColor'))
          .attr('fill-opacity', 1)
          .addDataset(this.get('datasetEvents'));

        this.focusPoint = new Plottable.Plots.Scatter()
          .x((d) => { return this._getUTCDate(d.start); }, this.get('xScale'))
          .y(function(d) { return d.value; }, this.get('yScale'))
          .size(10)
          .attr('fill', this.get('entityColorHover'))
          .attr('stroke', 'rgba(7,21,64,.25)')
          .attr('stroke-width', 10)
          .attr('opacity', 1)
          .addClass('focus-point')
          .addDataset(this.get('datasetForFocusPoint'));

        const gridlines = new Plottable.Components.Gridlines(this.get('xScale'), this.get('yScale'));
        const intensityGroup = new Plottable.Components.Group([
          gridlines,
          this.get('intensityPlots'),
          this.get('focusPoint')
        ]);

        this.eventPlots = new Plottable.Plots.Rectangle()
          .x((d) => { return this._getUTCDate(d.start); }, this.get('xScale'))
          .x2((d) => { return this._getUTCDate(d.end); })
          .y(function(d) { return 1; }, this.get('overviewYScale'))
          .attr('fill', (d) => {
            if(d.selected) {
              return this.get('entityColorHover');
            } else {
              return this.get('eventColor');
            }
          })
          .addDataset(this.get('datasetEvents'));

        const eventGridlines = new Plottable.Components.Gridlines(this.get('xScale'), null);
        const eventGroup = new Plottable.Components.Group([eventGridlines, this.get('eventPlots')]);

        // Panning and zooming on the chart
        // this.initPanZoomInteraction();

        this.chart = new Plottable.Components.Table([
                      [this.get('yAxis'), intensityGroup],
                      [null, this.get('xAxis')],
                      [null, eventGroup]
                    ])
                    .rowWeight(0, 5);

        Plottable.Dispatchers.Mouse.prototype.eventInside = function(component, event) {
          // debugger;
          const polymerEvent = { target: Polymer.dom(event).rootTarget };
          return this._translator.isInside(component, polymerEvent);
        };

        // Mouse interaction
        this.initPointerInteraction();

        // Mouse interaction for focus point
        this.initClickInteractionFocusPoint();

        // Render the chart
        this.chart.renderTo(this.$.chart);

        // Set the new domain based off of scrubber
        this.setDomain(this.viewerStart, this.viewerDuration);

        // Get annotations
        this.getAnnotations();
      },

      initPanZoomInteraction: function(eventGroup) {
        // Panning and zoom on the chart
        this.set('panZoomInteraction', new Plottable.Interactions.PanZoom());
        const panZoomInteraction = this.get('panZoomInteraction');

        panZoomInteraction.addXScale(this.get('xScale'));
        panZoomInteraction.attachTo(this.get('intensityPlots'));

        // Panning and zoom on the axis
        const pziXAxis = new Plottable.Interactions.PanZoom();
        pziXAxis.addXScale(this.get('xScale'));
        pziXAxis.attachTo(this.get('xAxis'));

        pziXAxis.onPanEnd((e) => {
          this.updateInfo(true);
        });

        panZoomInteraction.onPanEnd((e) => {
          this.updateInfo(true);
        });

        panZoomInteraction.onZoomEnd((e) => {
          this.updateInfo(true);
        });
      },

      /*
       * Reset the highlighted events
       */
      resetEventHighlight: function() {
        const datasetEvents = this.datasetEvents.data();

        // Reset color for all event entities
        datasetEvents.map((obj) => {
          obj.selected = false;
          return obj;
        });
      },

      initPointerInteraction: function() {
        // Interaction
        this.set('pointerInteraction', new Plottable.Interactions.Pointer());
        const interaction = this.get('pointerInteraction');

        // Mouse moving on chart
        interaction.onPointerMove((p) => {
          // Reset the highlighted events
          this.resetEventHighlight();

          // Account for the yAxis, since the pointer interaction is attached to the entire Table
          const adjustedX = p.x - this.yAxis.width();

          /*
           * Intensity
           * Highlight the intensity point the user is currently over
           */
          const intensityPlot = this.intensityPlots.entityNearestByXThenY({ x: adjustedX, y: p.y });
          if(intensityPlot) {
            const data = this.datasetForFocusPoint.data();
            // Don't show the tooltip and add the data if the data is already present
            if(data.indexOf(intensityPlot.datum) < 0) {
              this.datasetForFocusPoint.data([intensityPlot.datum]);
              this.getTooltipAnnotations(intensityPlot);
              this.showTooltip(intensityPlot);
            }
          }

          /*
           * Events
           * Highlight the event the user is currently over
           */
          const eventPlots = this.eventPlots.entitiesAt({ x: adjustedX, y: 0 });

          // Set color for matching event entity
          if(eventPlots.length) {
            eventPlots.map((obj) => {
              obj.datum.selected = true;

              // Redraw the event component
              obj.component.redraw();

              return obj;
            });
          }
        });

        // Mouse leaves chart
        interaction.onPointerExit((p) => {
          // Reset the highlighted events
          this.resetEventHighlight();

          // Clear the dataset for focus point
          this.get('datasetForFocusPoint').data([]);

          this.set('tooltipHidden', true);

          // Cancel the tooltip request
          const tooltipRequest = this.$.getTooltipAnnotation;
          if(tooltipRequest.lastRequest) {
            tooltipRequest.lastRequest.abort();
          }
        });

        // Attach the interaction to the chart
        interaction.attachTo(this.chart);

        // Overwrite interaction handler to not use insideSVG argument
        interaction._handlePointerEvent = function(p) {
            let translatedP = this._translateToComponentSpace(p);
            let overComponent = this._isInsideComponent(translatedP);
            if (overComponent) {
                if (!this._overComponent) {
                    this._pointerEnterCallbacks.callCallbacks(translatedP);
                }
                this._pointerMoveCallbacks.callCallbacks(translatedP);
            }
            else if (this._overComponent) {
                this._pointerExitCallbacks.callCallbacks(translatedP);
            }
            this._overComponent = overComponent;
        };
      },

      /**
       * Allows the user to click on the focus point
       */
      initClickInteractionFocusPoint: function() {
        this.set('focusPointClick', new Plottable.Interactions.Click());
        const clickInteraction = this.get('focusPointClick');

        clickInteraction.onClick((p) => {
          // Create a range the size of the focusPoint
          const rangeX = {
            min: p.x - 10,
            max: p.x + 10
          };

          // Create a range the size of the focusPoint
          const rangeY = {
            min: p.y - 10,
            max: p.y + 10
          };

          // Query for the focusPoint in the range
          const focusPoint = this.focusPoint.entitiesIn(rangeX, rangeY)

          // If the user is on the focusPoint, go to EEG
          if(focusPoint.length) {
            // Change to timeseries tab
            this.fire('set-selected-tab', { tab: 'timeseries' });

            this.fire('set-viewer-viewport', {
              start: focusPoint[0].datum.start,
              end: focusPoint[0].datum.end
            });
          }
        });

        clickInteraction.attachTo(this.focusPoint);
      },

      /**
       * Show and position the tooltip
       * @param {Object} position
       * @return {Boolean}
       */
      showTooltip: function(plot) {
        // Show the tooltip
        this.set('tooltipHidden', false);

        const tooltip = this.$.tooltip;
        const position = plot.position;

        // Account for the y-axis for positioning
        let posLeft = position.x + this.yAxis.width();

        // Set the tooltip's top position
        let posTop = -Math.abs(tooltip.offsetHeight) - 20 + position.y

        tooltip.style.top = posTop + 'px';

        // Set the tooltip's left position
        this.set('tooltipPosition', 'left');
        tooltip.style.left = posLeft + 'px';

        // Check if the tooltip is going offscreen
        const boundingBox = tooltip.getBoundingClientRect();
        if(boundingBox.left + boundingBox.width > window.innerWidth) {
          posLeft = posLeft - boundingBox.width;
          this.set('tooltipPosition', 'right');
          tooltip.style.left = posLeft + 'px';
        }

        // Check if the tooltip is going offscreen at the top
        if(boundingBox.top + boundingBox.height < this.offsetHeight) {
          posTop = posTop + boundingBox.height + 40;
          if(this.get('tooltipPosition') === 'left') {
            this.set('tooltipPosition', 'left-bottom');
          } else {
            this.set('tooltipPosition', 'right-bottom');
          }
          tooltip.style.top = posTop + 'px';
        }
      },

      _computeXAxis: function(xScale) {
        return new Plottable.Axes.Time(xScale, 'bottom');
      },

      _computeYAxis: function(yScale) {
        return new Plottable.Axes.Numeric(yScale, 'left');
      },

      onResize: function() {
        if(Object.keys(this.chart).length) {
          this.chart.redraw();
        }
      },

      updateInfo: function(shouldFire = '', domain = []) {
        if(shouldFire !== '') {
          this.fire('update-count', { eventType: shouldFire, domain: this.xScale.domain() });
          return;
        }

        if(domain.length > 1) {
          this.xScale.domain(domain);
        }

        const plots = this.get('eventPlots');
        const entities = plots.entitiesIn(plots.bounds());

        this.set('_entityCount', entities.length);
      },

      ajaxError: function(e, detail) {
        this.fire('ajaxError', { status: detail.request.status });
      },

      getAnnotations: function() {
        const request = this.$.getAnnotations;
        // Clear existing data before making the request
        this.get('datasetEvents').data([]);

        // Clear the dataset for focus point
        this.get('datasetForFocusPoint').data([]);

        // Set the new domain based off of scrubber
        this.setDomain(this.viewerStart, this.viewerDuration);

        request.params = {
          aggregation: 'count',
          start: Math.floor(this.viewerStart), // Allow for overflow
          end: Math.floor(this.viewerStart + this.viewerDuration), // Allow for overflow
          period: Math.floor(this.scrubberPeriod),
          api_key: this.user,
          mergePeriods: true
        }

        request.generateRequest();
      },

      _handleGetAnnotations: function(e, detail) {
        this.set('events', detail.response);
        if(Object.keys(this.chart).length === 0) {
          this.initCharts();
        }
      },

      /**
       * Executes api call to retrieve annotations for tooltip
       * @param {Object} plot object
       */
      getTooltipAnnotations: function(plot) {
        const request = this.$.getTooltipAnnotation;

        // Cancel the last ajax request
        if(request.lastRequest) {
          request.lastRequest.abort();
        }

        // Start a new request
        request.params = {
          api_key: this.user,
          start: Math.floor(plot.datum.start),
          end: Math.floor(plot.datum.end),
          limit: 1
        };
        request.generateRequest();
      },

      /**
       * Response from GET tooltip annotations
       * @param {Object} Event object
       * @param {Object} detail
       */
      _handleGetTooltipAnnotations: function(e, detail) {
        this.set('annotation', detail.response.results[0]);

        // Reposition the tooltip
        this.showTooltip(this.focusPoint.entities()[0]);
      },

      setDomain: function(start, duration) {
        if(Object.keys(this.chart).length) {

          const domain = [this._getUTCDate(start), this._getUTCDate(start + duration)];
          const xScale = this.get('xScale');

          xScale.domain(domain);
          this.updateInfo();

          return domain;
        }

        return [];
      },

      _getUTCDate: function(d) {
        if(d > 0) {
          const theDate = new Date(d / 1000);
          const startYear = theDate.getUTCFullYear();
          const startMonth = theDate.getUTCMonth();
          const startDay = theDate.getUTCDate();
          const startHours = theDate.getUTCHours();
          const startMinutes = theDate.getUTCMinutes();
          const startSeconds = theDate.getUTCSeconds();
          return new Date(startYear, startMonth, startDay, startHours, startMinutes, startSeconds);
        }
      }
    });

  </script>
</dom-module>
