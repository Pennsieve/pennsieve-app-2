<link rel="import" href="../../../../../../bower_components/polymer/polymer.html">

<script>
  window.Blackfynn = window.Blackfynn || {};
  /**
  * @polymerBehavior
  */
    Blackfynn.TSAnnotationBehavior = {
      properties:{
        constants: {
            type: Object,
            value: function() {return {}}
        },
        // Array of Layers
        annLayers: {
            notify: true,
            type: Array,
            value: function() { return []; }
        },
        // Array with all annotation ids --> used for checking doubles
        annotations:{
            notify:true,
            type: Array,
            value: function() { return []; }
        },
        // Array of requested annotation ranges
        cachedAnnRange:{
            type: Array,
            value: function() { return []; }
        },
        // Pointer to the parent Object
        parent: {
            type: Object,
            value: null
        },
        // Pointer to the hovered Annotation
        focusedAnn:{
            type: Object,
            value: null
        },
        selectedAnns: {
            type: Array,
            value: function() { return []; }
        },
        // Array of canvas offsets where mouse-over should check for annotations.
        hoverOffsets: {
            type: Array,
            value:null
        },
        renderAnn:{
            type: Array,
            value: function() { return []; }
        },
        startDragCoord:{
            type: Number,
            value:null
        },
        a11yList: {
          type: Array,
          value: function() {
            return ['#FFFF4E']
          }
        },
    },

    observers: [
      '_watchState(vuex.viewer.viewerAnnotations.*)'
    ],

    /**
     * watches for changes in viewer layers
     * @param {Array} annotations
     */
    _watchState(annotations) {
      const layers = R.compose(
        R.defaultTo([]),
        R.propOr([], 'base')
      )(annotations)
      if (layers.length > 0) {
        this.render();
      }
    },

    findNextAnnotation: function(curTime) {
        let annLayer = this.$store.getters['viewer/getViewerActiveLayer']();
        const index = this.annIndexOf(annLayer.annotations, curTime, false);

        if(index < annLayer.annotations.length) {
            return annLayer.annotations[index + 1];
        } else {
            return annLayer.annotations[index];
        }
    },
    findPrevAnnotation: function(curTime) {
        let annLayer = this.$store.getters['viewer/getViewerActiveLayer']();
        const index = this.annIndexOf(annLayer.annotations, curTime, true);

        if(index > 0 ) {
            return annLayer.annotations[index - 1];
        } else {
            return annLayer.annotations[index];
        }
    },
    findIndexOfAnn: function(ann, annLayer) {
        if (annLayer) {
            for(let i=0; i<annLayer.annotations.length; i++) {
                if(annLayer.annotations[i].id === ann.id) {
                    return i;
                }
            }
        } else {
            for (let l2 in this.vuex.viewer.viewerAnnotations) {
                if (this.vuex.viewer.viewerAnnotations.hasOwnProperty(l2)) {
                  const curAnnLayer = this.vuex.viewer.viewerAnnotations[l2];
                  for(let i2=0; i2 < curAnnLayer.annotations.length; i2++) {
                      if(curAnnLayer.annotations[i2].id === ann.id) {
                          return i2;
                      }
                  }
                }
            }
        }
        return null;
    },
    annIndexOf: function(annArray, val, first, startAtIndex, checkEnd) {

        if (!startAtIndex) {
            startAtIndex = 0;
        }

        let index;
        if (checkEnd) {
            index = this._indexOfEnd(annArray, val, startAtIndex, annArray.length - 1, first);
        } else {
            index = this._indexOfStart(annArray, val, startAtIndex, annArray.length - 1, first);
        }

        if (index === -1) {
            index = 0;
        } else if (index < 0) {
            index = -index - 2;
        }
        return index;
    },
    _indexOfStart: function(annArray, val, min, max, firstIndex) {

        /*
         Return code status:
         Positive number:  first index of the value
         Negative 1 (-1):  belongs before the start of the dataset
         Other negative value:  belongs after (-value - 2)
         */
        if (max < min) {
            let pred;
            if (max >= 0) {
                //return -max - 2;
                pred = max;
            } else {
                //return max;
                pred = -max - 2;
            }
            if (pred === -1) {
                return pred;
            }
            const predVal = annArray[pred].start;
            while (pred >= 0 && annArray[pred].start === predVal) {
                pred--;
            }
            pred++;
            return -pred - 2;
        }

        const mid = parseInt((min + max) / 2);

        if (annArray[mid].start > val) {
            return this._indexOfStart(annArray, val, min, mid - 1, firstIndex);
        } else if (annArray[mid].start < val) {
            return this._indexOfStart(annArray, val, mid + 1, max, firstIndex);
        } else {
            let index = mid;
            if (firstIndex) {
                while (index >= 0 && annArray[index].start === val) {
                    index--;
                }
                index++;
            } else {
                while (index < annArray.length && annArray[index].start === val) {
                    index++;
                }
                index--;
            }
            return index;
        }
    },
    _indexOfEnd: function(annArray, val, min, max, firstIndex) {

        /*
         Return code status:
         Positive number:  first index of the value
         Negative 1 (-1):  belongs before the start of the dataset
         Other negative value:  belongs after (-value - 2)
         */

        if (max < min) {
            let pred;
            if (max >= 0) {
                //return -max - 2;
                pred = max;
            } else {
                //return max;
                pred = -max - 2;
            }
            if (pred === -1) {
                return pred;
            }
            const predVal = annArray[pred].start + annArray[pred].duration;
            while (pred >= 0 && (annArray[pred].start + annArray[pred].duration) === predVal) {
                pred--;
            }
            pred++;
            return -pred - 2;
        }

        const mid = parseInt((min + max) / 2);

        if ( (annArray[mid].start + annArray[mid].duration) > val) {
            return this._indexOfEnd(annArray, val, min, mid - 1, firstIndex);
        } else if ((annArray[mid].start + annArray[mid].duration) < val) {
            return this._indexOfEnd(annArray, val, mid + 1, max, firstIndex);
        } else {
            let index = mid;
            if (firstIndex) {
                while (index >= 0 && (annArray[index].start + annArray[index].duration) === val) {
                    index--;
                }
                index++;
            } else {
                while (index < annArray.length && (annArray[index].start + annArray[index].duration) === val) {
                    index++;
                }
                index--;
            }

            return index;
        }
    },
    sortAnns: function(annArray) {
        annArray.sort(function Comparator(a, b) {
            if (a.start < b.start) return -1;
            if (a.start > b.start) return 1;
            return 0;
        });
    },
    // Is called when annotation is updated --> should update server
    annotationUpdated: function(payload) {
        const ajax = this.$.updateAnnotationAjax;
        const apiUrl = this.vuex.config.apiUrl
        ajax.url = `${apiUrl}/timeseries/${this.summary.content.id}/layers/${payload.layer_id}/annotations/${payload.id}?api_key=${this.vuex.userToken}`;

        ajax.body = {
            name: payload.name,
            description: payload.description,
            label: payload.label,
            channelIds: payload.channelIds,
            end: payload.end,
            start: payload.start,
            layer_id: payload.layer_id
        }

        const pkg = payload.linkedPackage
        if (pkg && typeof(pkg) === 'string') {
          ajax.body.linkedPackage = pkg
        } else if (pkg) {
          ajax.body.linkedPackage = R.pathOr('', ['content', 'id'], pkg)
        }

        ajax.generateRequest();

        this.fire('reset-annotation-window')
    },

    // Is called when annotation layer is updated --> should update server
    layerUpdated: function(layer) {
        const ajax = this.$.updateLayerAjax;
        const apiUrl = this.vuex.config.apiUrl
        ajax.url = `${apiUrl}/timeseries/${this.summary.content.id}/layers/${layer.id}?api_key=${this.vuex.userToken}`;
        ajax.body = {
            name: layer.label,
            color: layer.color || '#18BA62',
            description: layer.description
        };
        ajax.generateRequest();
    },

    _computeRenderOptions: function(anns) {

        const annotationHeight = this.constants['ANNOTATIONLABELHEIGHT'];
        const halfAnnotationHeight = (annotationHeight/2) |0;

        const xOffset = this.constants['XOFFSET'];

        const remIdx = [];

        for (let annIdx=0; annIdx< anns.length; annIdx++) {
            const curAnn = anns[annIdx];

            // Invert if duration is negative
            let viewStart = curAnn.start;
            let viewDuration = curAnn.duration;
            if (curAnn.duration < 0) {
                viewStart = (curAnn.start + curAnn.duration);
                viewDuration = -curAnn.duration;
            }

            const curAnnStart = xOffset + (viewStart - this.parent.start ) / this.parent.rsPeriod;
            curAnn.cStart = curAnnStart | 0;


            if (curAnn.duration !== 0) {
                const curAnnEnd = xOffset + (viewStart + viewDuration - this.parent.start ) / this.parent.rsPeriod;
                curAnn.cEnd = curAnnEnd | 0;          // round to integer
            } else {
                curAnn.cEnd = (curAnn.cStart + this.parent.cWidth/40) | 0;   // round to integer
            }


            if (!curAnn.allChannels) {
                curAnn.allOffsets = [];
                curAnn.minOffset = this.parent.cHeight | 0;
                curAnn.maxOffset = 0;

                const channelConfig = this.vuex.viewer.viewerChannels;
                for (let ch1 in curAnn.channelIds) {
                  if (curAnn.channelIds.hasOwnProperty(ch1)) {
                    // find channel
                    let channelOffset = null;
                    for (let ch2 in channelConfig) {
                      if (channelConfig.hasOwnProperty(ch2)) {
                        const curChannelView = channelConfig[ch2];
                        if(curChannelView.id === curAnn.channelIds[ch1] && curChannelView.visible) {
                            channelOffset = curChannelView.rowBaseline | 0;
                            if (channelOffset < curAnn.minOffset) { curAnn.minOffset = channelOffset; }
                            if (channelOffset > curAnn.maxOffset) { curAnn.maxOffset = channelOffset; }
                            curAnn.allOffsets.push(channelOffset);
                            break;
                        }
                      }
                    }
                  }
                }

                // Add to hoverOffsets
                if (this.hoverOffsets.indexOf(curAnn.minOffset) < 0) {
                    this.push('hoverOffsets', curAnn.minOffset );
                }
                curAnn.cY = curAnn.minOffset;  // set renderOffset

            } else {
                curAnn.allOffsets = [halfAnnotationHeight];
                curAnn.cY = halfAnnotationHeight;  // set renderOffset
            }


        }

        for (let j = (remIdx.length-1); j>=0; j--) {
            anns.splice(remIdx[j], 1);
        }
    },
    setActiveLayer: function(layer = {}) {
      const layers = R.clone(this.vuex.viewer.viewerAnnotations)
      const layerId = R.propOr('', 'id', layer)


      for (const l in layers) {
        if (layers.hasOwnProperty(l)) {
          if (R.propOr('', 'id', layers[l]) === layerId) {
              layers[l].selected = true
          } else {
              layers[l].selected = false
          }
        }
      }

      this.$store.dispatch('viewer/setAnnotations', layers).then(() => {
        this.set('activeLayer', layer);
        this.fire('newactivelayer', layer);
      })
    },
    getLayer: function(annotation) {
      const layerId = R.propOr(0, 'layer_id', annotation)
      return R.defaultTo({}, R.find(R.propEq('id', layerId), this.vuex.viewer.viewerAnnotations))
    },
    _renderAnnotationAreas: function(ctx, anns) {
        const annotationHeight = this.constants['ANNOTATIONLABELHEIGHT'];
        const halfAnnotationHeight = (annotationHeight/2) |0;
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

        ctx.save();
        ctx.lineWidth = 1;
        ctx.setLineDash([8, 5]);
        ctx.strokeStyle = 'rgba(0,0,0, 0.6)';
        ctx.fillStyle = 'rgba(0,0,0,0.05)';
        for (const ann in anns) {
          if (anns.hasOwnProperty(ann)) {
            const curAnn = anns[ann];
            const curAnnLayer = this.getLayer(curAnn)
            if (curAnn.selected) {
                ctx.save();
                ctx.strokeStyle = curAnnLayer.selColor;
                ctx.fillStyle = curAnnLayer.bkColor;
                ctx.lineWidth = 1;
            }
            // Switch render based on type: 1) global 2) Globalpoint 3) channel 4) channelPoint
            let curAnnStartRounded = Math.round(curAnn.cStart) + 0.5;
            let curAnnEndRounded = Math.round(curAnn.cEnd) + 0.5;
            if (curAnn.allChannels) {

                // On all channels
                if (curAnn.duration === 0) {
                    // No duration
                    // Background area
                    ctx.beginPath();
                    ctx.moveTo(curAnnStartRounded +1, annotationHeight);
                    ctx.lineTo(curAnnStartRounded, this.parent.pHeight);
                    ctx.stroke();
                } else{
                    // With duration
                    // Background area
                    ctx.fillRect(curAnnStartRounded, annotationHeight, curAnnEndRounded - curAnnStartRounded, this.parent.pHeight - annotationHeight);
                    ctx.beginPath();
                    ctx.moveTo(curAnnStartRounded, annotationHeight);
                    ctx.lineTo(curAnnStartRounded, this.parent.pHeight);
                    ctx.moveTo(curAnnEndRounded, annotationHeight);
                    ctx.lineTo(curAnnEndRounded, this.parent.pHeight);
                    ctx.stroke();
                }
            } else if(curAnn && curAnn.channelIds && curAnn.channelIds.length === 1) {
                // Flagpole in case of single channel with no duration
                if (curAnn.duration === 0) {
                    ctx.beginPath();
                    ctx.moveTo(curAnnStartRounded, curAnn.minOffset + halfAnnotationHeight);
                    ctx.lineTo(curAnnStartRounded, curAnn.minOffset + halfAnnotationHeight + 8);
                    ctx.stroke();
                }
            } else {
                // On multiple channels
                if (curAnn.duration === 0) {
                    // No duration
                    ctx.beginPath();
                    ctx.moveTo(curAnnStartRounded, curAnn.minOffset +halfAnnotationHeight);
                    ctx.lineTo(curAnnStartRounded, curAnn.maxOffset-halfAnnotationHeight );
                    ctx.stroke();
                } else{
                    // With duration
                    ctx.fillRect(curAnnStartRounded-1, curAnn.minOffset+halfAnnotationHeight,
                            curAnnEndRounded-curAnnStartRounded + 1, curAnn.maxOffset-curAnn.minOffset -annotationHeight);
                    ctx.beginPath();
                    ctx.moveTo(curAnnStartRounded, curAnn.minOffset + halfAnnotationHeight);
                    ctx.lineTo(curAnnStartRounded, curAnn.maxOffset - halfAnnotationHeight );
                    ctx.moveTo(curAnnEndRounded, curAnn.minOffset + halfAnnotationHeight);
                    ctx.lineTo(curAnnEndRounded, curAnn.maxOffset - halfAnnotationHeight);
                    ctx.stroke();
                }
            }
            if (curAnn.selected) {
                ctx.restore();
            }
          }
        }
        ctx.restore();
    },
    _renderAnnotationLabels: function(ctx, anns, hideFocusedAnn) {
        const annotationHeight = this.constants['ANNOTATIONLABELHEIGHT'];
        const halfAnnotationHeight = (annotationHeight/2) |0;

        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

        ctx.save();
        ctx.lineWidth = 2;
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'left';

        for (let iAnn=0; iAnn<anns.length; iAnn++) {
            const curAnn = anns[iAnn];
            const curAnnLayer = this.getLayer(curAnn)

            if (curAnn === this.focusedAnn && hideFocusedAnn) {
                continue;
            }
            // Set options
            if (curAnn.selected) {
                ctx.fillStyle = curAnnLayer.selColor || 'rgba(51,204,102, 0.8)';
                ctx.strokeStyle = 'white';
            } else {
                ctx.fillStyle = curAnnLayer.color || 'rgba(51,204,102,0.8)';
                if (curAnn === this.focusedAnn) {
                    ctx.strokeStyle = 'white';
                } else{
                    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                }
            }

            let curAnnStartRounded = Math.round(curAnn.cStart) + 1;
            let curAnnEndRounded = Math.round(curAnn.cEnd);

            // Render label background
            let minOffsetIdx = 0;
            for (let i = 0; i < curAnn.allOffsets.length; i++) {
                ctx.fillRect(curAnnStartRounded - 1, curAnn.allOffsets[i] -
                        halfAnnotationHeight, curAnnEndRounded - curAnnStartRounded + 2, annotationHeight);
                if (curAnn.allOffsets[i] === curAnn.minOffset) {
                    minOffsetIdx = i;
                }
            }

            // Render Inside lines (resize handles)
            const firstOffset = curAnn.allOffsets[minOffsetIdx];
            if (this.parent.actionMode === 'annotate') {
                ctx.beginPath();

                if (curAnn.duration !== 0) {
                    ctx.moveTo(curAnnEndRounded - 3, firstOffset - halfAnnotationHeight + 3);
                    ctx.lineTo(curAnnEndRounded - 3, firstOffset + halfAnnotationHeight - 3);
                }
                ctx.moveTo(curAnnStartRounded + 3, firstOffset - halfAnnotationHeight + 3);
                ctx.lineTo(curAnnStartRounded + 3, firstOffset + halfAnnotationHeight - 3);
                ctx.stroke();
            }

            // fill text
            if ((curAnnEndRounded - curAnnStartRounded) > ( (curAnn.label.length * 8) + 10)) {
                ctx.fillStyle = this.a11yList.indexOf(curAnnLayer.hexColor) >= 0 ? 'black' : 'white'
                if (!curAnn.linkedPackage) {
                  ctx.fillText(curAnn.label, curAnnStartRounded + 10, firstOffset + halfAnnotationHeight - 6);
                } else {
                  ctx.fillText(curAnn.label, curAnnStartRounded + 30, firstOffset + halfAnnotationHeight - (halfAnnotationHeight / 2));
                }
            }

            const linkedPackageDTO = curAnn.linkedPackageDTO

            if (linkedPackageDTO && (curAnnEndRounded - curAnnStartRounded) >= 30 ) {
              const preview = R.pathOr({}, ['objects', 'view', 1, 'content'], linkedPackageDTO)
              const fileType = R.propOr('', 'fileType', preview)

              const img = new Image()

              // if there's an image preview available
              if (fileType === 'PNG') {
                const { id, packageId } = preview
                const apiUrl = this.vuex.config.apiUrl
                img.src = `${apiUrl}/packages/${packageId}/files/${id}/presign/?api_key=${this.vuex.userToken}`
                if (!img.complete) {
                  img.addEventListener('load', () => this.render(), { once: true })
                }
                ctx.drawImage(img, curAnnStartRounded, firstOffset - halfAnnotationHeight, 27, annotationHeight)
              } else {
                const iconPath = this._computeIcon(linkedPackageDTO)
                img.src = iconPath
                ctx.drawImage(img, curAnnStartRounded + 5, firstOffset - halfAnnotationHeight, 20, 20)
              }
            }
        }

        ctx.restore();
    },

    /**
     * Returns channel ID
     * @param {Object}
     * @returns {String}
     */
    getChannelId: function(channel) {
      const isViewingMontage = this.vuex.viewer.viewerMontageScheme !== 'NOT_MONTAGED'
      let id = R.propOr('', 'id', channel)
      let list = []
      if (isViewingMontage) {
        list = id.split('_')
        id = list.length ? R.head(list) : id // remove channel name from id
      }
      return id
    },

    deleteAnnotation: function(annotation) {
      let annLayerId = ''
      // annotation data structure properties vary depending on if the user
      // is canceling newly created annotation or not
      if (annotation.layer) {
        annLayerId = annotation.layer.id
      } else {
        annLayerId = annotation.layerId
      }
      const ajax = this.$.delAnnotationAjax;
      const apiUrl = this.vuex.config.apiUrl
      ajax.url = `${apiUrl}/timeseries/${this.summary.content.id}/layers/${annLayerId}/annotations/${annotation.id}?api_key=${this.vuex.userToken}`;

      ajax.generateRequest().completes.then(() => {
        this.$store.dispatch('viewer/deleteAnnotation', annotation)

        // message user
        if (annotation.toast) {
          this.fire('toast', {type: 'MESSAGE', msg: 'Annotation deleted'});
        }

        // re-render canvas
        this.render();

        // update scrubber
        this.annotationChange(annLayerId);
      });
    },

    applyAnnotationsToChannels: function() {
        // find selected Annotation

        const channelConfig = this.vuex.viewer.viewerChannels;

        for (let i in this.selectedAnns) {
          if (this.selectedAnns.hasOwnProperty(i)) {
            const selAnn = this.selectedAnns[i];

            // Check if all channels are selected:
            let allSelected = true;
            const oldChannels = selAnn.channelIds;
            selAnn.channelIds = [];
            for (let ch in channelConfig) {
              if (channelConfig.hasOwnProperty(ch)) {
                allSelected = allSelected && channelConfig[ch].selected;
                if (channelConfig[ch].selected) {
                    const id = this.getChannelId(channelConfig[ch])
                    selAnn.channelIds.push(id);
                }
              }
            }

            // If no channels were selected, revert back to old state
            if (selAnn.channelIds.length === 0) {
                selAnn.channelIds = oldChannels;
            } else {
                // Set all channels if allchannels are selected
                if (allSelected) {
                    selAnn.allChannels = true;
                } else {
                    selAnn.allChannels = false;
                }

                // Delete annotation from server.
                this.deleteAnnotation(selAnn);

                // Add new annotation to server.
                selAnn.id = '';
                this.addAnnotation(selAnn.start, selAnn.duration, false, selAnn.label, selAnn.description, selAnn.layer.label);
            }
          }
        }

        this.render();
    },
    // Check if annotations are available in client and request from server if not
    checkAnnotationRange: function(RStart, REnd) {
        // return if no layers have been defined.
        if (this.vuex.viewer.viewerAnnotations.length === 0) {
            return
        }

        // If part of the viewport is not cached, request up to limit.
        // Start with full width --> split on exisiting ranges
        const reqRange = [];
        reqRange.push({start: RStart, end: this.summary.span.end});
        // check if viewport is cached
        let firstIndex = 0;
        for (let i = 0; i < this.cachedAnnRange.length; i++) {
            const curBlock = this.cachedAnnRange[i];
            if( RStart >= curBlock.start && REnd <= curBlock.end ) {
                // annotations in current viewport are cached
                return
            } else if (reqRange[0].start > REnd) {
                break;
            } else if (curBlock.start <= reqRange[0].start && curBlock.end >= RStart) {
                // existing cached partly in viewport
                firstIndex = i + 1;
                reqRange[0].start = curBlock.end;
            } else if (curBlock.start > reqRange[0].start ) {
                // block start is beyond viewport
                firstIndex = i;
                break;
            }
        }

        // check if layers have annotations
        const annotationsTotal = this.vuex.viewer.viewerAnnotations.reduce((acc, li) => acc = li.annotations.length)

        // If all in memory, return
        if(reqRange[0].start >= reqRange[0].end && annotationsTotal > 0) {
            return;
        }
        // Now find ranges
        const curRequestIndex = 0;
        for (let i = firstIndex; i < this.cachedAnnRange.length; i++) {
            if (this.cachedAnnRange[i].start >= reqRange[curRequestIndex].start) {
                reqRange[curRequestIndex].end = this.cachedAnnRange[i].start;
                // Only add new request if within viewport
                if (this.cachedAnnRange[i].end < REnd) {
                    reqRange.push({start: this.cachedAnnRange[i].end, end: this.summary.span.end});
                } else {
                    break;
                }
            }
        }
        // If all in viewport in memory, return
        if(reqRange[0].start >= reqRange[0].end && annotationsTotal > 0) {
            return;
        }
        // Request annotations from server if any need to be requested.
        if ( (reqRange.length > 0) ) {
            const channelIds = [];
            for (let i=0; i< this.vuex.viewer.viewerChannels.length; i++) {
                const channel = this.vuex.viewer.viewerChannels[i]
                const id = this.getChannelId(channel)
                channelIds.push(id);
            }
            // Request new range
            for (let cur in reqRange) {
              if (reqRange.hasOwnProperty(cur)) {
                const curRange = reqRange[cur];
                for (let lyr = 0; lyr < this.vuex.viewer.viewerAnnotations.length; lyr++) {
                    const curLayer = this.vuex.viewer.viewerAnnotations[lyr];
                    const endTime = Math.floor(curRange.end);
                    const params = {
                        id: this.summary.content.id,
                        start: Math.floor(curRange.start),
                        end: endTime,
                        layerId: curLayer.id,
                        limit: this.constants['LIMITANNFETCH']
                    }
                    const apiUrl = this.vuex.config.apiUrl
                    const baseUrl = `${apiUrl}/timeseries/${this.summary.content.id}/layers/${curLayer.id}/annotations?api_key=${this.vuex.userToken}`;
                    const urlParams = Object.keys(params).map(k => `&${k}=${params[k]}`).join('');
                    const url = `${baseUrl}${urlParams}`;
                    fetch(url, {
                      method: 'GET',
                      headers: {
                        'Content-type': 'application/json'
                      }
                    })
                    .then(response => {
                      const {status} = response;
                      if (status >= 400) {
                        throw new Error(status);
                      }
                      return response.json();
                    })
                    .then(this._getAnnResponse.bind(this))
                    .catch(this.ajaxError.bind(this));
                }
                this.cachedAnnRange.push({start: Math.floor(curRange.start), end: Math.floor(curRange.end)});
              }
            }
            // Sort the returned annotations by end-time
            this.cachedAnnRange.sort(function Comparator(a, b) {
                if ( a.start < b.start) return -1;
                if ( a.start > b.start ) return 1;
                return 0;
            });
        }
    },
    render: function() {
        const ctxBk = this.canvasArr[0].getContext('2d');
        const ctxLb = this.canvasArr[1].getContext('2d');
        ctxBk.setTransform(this.parent.pixelRatio, 0, 0, this.parent.pixelRatio, 0, 0);
        ctxLb.setTransform(this.parent.pixelRatio, 0, 0, this.parent.pixelRatio, 0, 0);


        // Init hover offsets --> used to track which channels contain individual annotations.
        this.set('hoverOffsets', [this.constants['ANNOTATIONLABELHEIGHT']/2]);

        // clear canvas
        ctxBk.clearRect(0, 0, this.parent.cWidth, this.parent.cHeight );
        ctxLb.clearRect(0, 0, this.parent.cWidth, this.parent.cHeight );

        // clear Render Annotations Array
        this.renderAnn = [];

        // Iterate over visible layers and populate render array
        for(let iL in this.vuex.viewer.viewerAnnotations) {
          if (this.vuex.viewer.viewerAnnotations.hasOwnProperty(iL)) {
            const curLayer = this.vuex.viewer.viewerAnnotations[iL];

            if (curLayer.visible && curLayer.annotations && curLayer.annotations.length > 0) {

                // Get last index in (start-sorted) array of annotations that start before end of window
                const lastIndex = this.annIndexOf(curLayer.annotations, this.parent.start + this.parent.duration, false, 0, false);

                const priorAnns = [];
                for (let iAnn = 0; iAnn <= lastIndex; iAnn++) {
                    priorAnns.push(curLayer.annotations[iAnn]);
                }

                // Sort the returned annotations by end-time
                priorAnns.sort(function Comparator(a, b) {
                    if ( (a.start + a.duration) < (b.start + b.duration)) return -1;
                    if ((a.start + a.duration) > (b.start + b.duration)) return 1;
                    return 0;
                });

                // Find the first index in (end-sorted) array of annotations that end after start of window
                const first = this.annIndexOf(priorAnns, this.parent.start, true, 0, true);

                // Populate renderArray of annotations.
                for (let iAnn = first; iAnn <= priorAnns.length-1; iAnn++) {
                    const curAnn = priorAnns[iAnn];

                    // Make sure that annotation points back to layer
                    // curAnn.layer = curLayer;
                    this.renderAnn.push(curAnn);
                }
            }
          }
        }

        // Sort rendered annotations
        this.sortAnns(this.renderAnn);

        // Compute all render-variables
        this._computeRenderOptions(this.renderAnn);

        // Render all backGrounds
        this._renderAnnotationAreas(ctxBk, this.renderAnn);

        // Render focus backGround
        this._renderAnnotationLabels(ctxLb, this.renderAnn, true);

        // Render focus Label
        if(this.focusedAnn !== null) {
            this._renderAnnotationLabels(ctxLb, [this.focusedAnn], false);
        }

    },
    onMouseMove: function(mX, mY, pointerMode, actionMode, mouseDown) {
        const annHeight = this.constants['ANNOTATIONLABELHEIGHT'];
        const annotationPopover = this.parent.$.annotationPopover
        const innerCanvas = this.parent.$.iArea
        const halfAnnHeight = annHeight/2;
        let newPointerMode = pointerMode;

        if (mouseDown) {
            annotationPopover.style.opacity = 0;
            annotationPopover.style.display = 'none';
            return newPointerMode;
        }

        // Determine if we should check for annotations
        let checkAnns = false;
        if (pointerMode !== 'pan') {
            for (let o=0; o< this.hoverOffsets.length; o++) {
                if (mY >= (this.hoverOffsets[o] - halfAnnHeight) && mY <= (this.hoverOffsets[o] + halfAnnHeight)) {
                    checkAnns = true;
                    break;
                }
            }
        }

        // If not in pan mode && in annotations area ---> update
        if(checkAnns) {
            // Check if hovering over annotation
            let onAnn = null;
            for(let i = 0; i < this.renderAnn.length; i++) {

                if( (this.renderAnn[i].cStart) < mX && (this.renderAnn[i].cEnd) > mX) {

                    // Now check annotation offset
                    if( mY > (this.renderAnn[i].cY - halfAnnHeight) && mY < (this.renderAnn[i].cY + halfAnnHeight) ) {
                        onAnn = i;
                    }

                } else if(this.renderAnn[i].cStart > mX ) {
                    // Break on first annotation where start > mX
                    break;
                }

            }

            // Setting the cursor pointer
            if (onAnn !== null) {
                const oldFocus = this.focusedAnn;

                // If no focus, or focused but now outside range ---> update focus to annotation under cursor
                if (oldFocus === null || (this.focusedAnn && (mX < this.focusedAnn.cStart || mX > this.focusedAnn.cEnd )) ) {
                    this.focusedAnn = this.renderAnn[onAnn];
                }

                // Check which activeArea
                switch (actionMode) {
                    case 'annotate':
                        if (mX <= (this.focusedAnn.cStart + 10)) {
                            newPointerMode = 'annResize-left';
                        } else if ( mX >= (this.focusedAnn.cEnd - 10) && this.focusedAnn.duration > 0 ) {
                            newPointerMode = 'annResize-right';
                        } else {
                            newPointerMode = 'annSelect';
                        }
                        break;
                    case 'point':
                        newPointerMode = 'annSelect';
                        break;
                }

                const { cStart } = this.focusedAnn
                const isOverThumbnail = (mX >= cStart + 10 && mX <= cStart + 40)
                const innerCanvasPositions = innerCanvas.getBoundingClientRect()

                if (isOverThumbnail) {
                  annotationPopover.annotation = this.focusedAnn
                  annotationPopover.showMore = false
                  annotationPopover.style.left = `${cStart}px`
                  annotationPopover.carrot = true
                  annotationPopover.style.top = '70px'
                  annotationPopover.style.opacity = 1
                  annotationPopover.style.display = 'block'

                  // if annotation start position is less than 150px from the right edge of inner canvas
                  if (innerCanvas.width - cStart < 150) {
                    annotationPopover.carrot = false
                    annotationPopover.style.left = `${innerCanvas.width - 135}px`
                  }

                  // if annotation start position + inner canvas start position is less than popover width
                  if (cStart + innerCanvasPositions.x < 225) {
                    annotationPopover.carrot = false
                    annotationPopover.style.left = `95px`
                  }
                }

                // rerender annotations when hovering over different annotation than previous call
                if (oldFocus !== this.focusedAnn) {
                    this.render();
                }
            } else {
                newPointerMode = actionMode;
                // remove focus on annotation
                if (this.focusedAnn !== null) {
                    this.focusedAnn = null;
                    this.render();
                }
            }

        } else {
            // in pan mode
            newPointerMode = actionMode;

            // remove focus on annotation
            if (this.focusedAnn !== null) {
                this.focusedAnn = null;
                this.render();
            }
        }

        return newPointerMode;
    },
    onTrack: function(e, pointerMode) {

        switch (e.detail.state) {
            case 'start':
                switch (pointerMode) {
                    case 'annResize-left':
                    case 'annResize-right':
                        this.focusedAnn.oldStart = this.focusedAnn.start;
                        this.focusedAnn.oldDuration = this.focusedAnn.duration;
                        break;
                    case 'annotate':
                        if (!e.detail.sourceEvent.shiftKey) {
                            const iCanvas = this.parent.$.iArea;
                            const xStart = e.detail.x - e.detail.dx - iCanvas.getBoundingClientRect().left;
                            this.startDragCoord = this.parent.start + xStart * this.parent.rsPeriod;
                            this.startDragCoordPx = xStart;
                            break;
                        }
                }

                break;
            case 'track':

                switch (pointerMode) {
                    case 'pan':
                        break;
                    case 'annResize-left':
                        if (this.focusedAnn.oldDuration > 0) {
                            this.focusedAnn.start = (this.focusedAnn.oldStart + (e.detail.dx * this.parent.rsPeriod));
                            this.focusedAnn.duration = (this.focusedAnn.oldDuration - (e.detail.dx * this.parent.rsPeriod) );
                            this.focusedAnn.end = this.focusedAnn.start + this.focusedAnn.duration;
                        } else {
                            this.focusedAnn.start = (this.focusedAnn.oldStart + (e.detail.dx * this.parent.rsPeriod));
                        }

                        this.render();
                        break;
                    case 'annResize-right':
                        this.focusedAnn.duration = (this.focusedAnn.oldDuration + (e.detail.dx * this.parent.rsPeriod) );
                        this.focusedAnn.end = this.focusedAnn.start + this.focusedAnn.duration;

                        this.render();
                        break;

                    case 'annotate':
                        this.renderAnnotationBox(e.detail);
                        break;
                }


                break;
            case 'end':
                // Always clear interactive canvas


                switch (pointerMode) {
                    case 'annResize-left':
                    case 'annResize-right':
                        this.focusedAnn.oldStart = null;
                        this.focusedAnn.oldDuration = null;

                        if (this.focusedAnn.duration < 0) {
                            this.focusedAnn.start = this.focusedAnn.start + this.focusedAnn.duration;
                            this.focusedAnn.duration = -this.focusedAnn.duration;
                            this.focusedAnn.end = this.focusedAnn.start + this.focusedAnn.duration;
                        }
                        const activeLayer = R.find(R.propEq('id', this.focusedAnn.layer_id), this.vuex.viewer.viewerAnnotations);
                        const layerAnns = R.propOr([], 'annotations', activeLayer)
                        this.sortAnns(layerAnns);
                        this.render();
                        this.annotationUpdated(this.focusedAnn);
                        break;
                    case 'annotate':
                        // Find active layer
                        let curLIndex = null;
                        for (let i=0; i<this.vuex.viewer.viewerAnnotations.length; i++) {
                            if (this.vuex.viewer.viewerAnnotations[i].selected) {
                                curLIndex = i;
                                break;
                            }
                        }

                        // No layers
                        if (curLIndex === null) {
                            return;
                        }

                        const selectedChannels = this.$store.getters['viewer/viewerSelectedChannels']
                        const allChannels = selectedChannels.length === this.vuex.viewer.viewerChannels.length || selectedChannels.length === 0

                        this.addAnnotation(this.startDragCoord, e.detail.dx *this.parent.rsPeriod, allChannels, this.defaultLabels[this.labelSelect], '', this.vuex.viewer.viewerAnnotations[curLIndex] );
                        break;
                }
                break;
        }
    },
    addAnnotation: function(start, duration, onAll, label, description, layer) {
        // correct negative durations
        if (duration < 0 ) {
            duration = -duration;
            start = start - duration;
        }

        const onChannels = [];
        for (let ch = 0; ch < this.vuex.viewer.viewerChannels.length; ch++) {
            const curChannelView = this.vuex.viewer.viewerChannels[ch];
            if((curChannelView.selected && curChannelView.visible) || onAll) {
                const id = this.getChannelId(curChannelView)
                onChannels.push(id);
            }
        }

        const newAjaxAnn = {
            name: '',
            channelIds: onChannels,
            label: label,
            description: description,
            layer_id: layer.id,
            start: start,
            end: start + duration
        }

        //Unselect current annotations
        this.unSelectAnnotations(null, false);

        // Send ADD annotation request to server
        const aj = this.$.addAnnotationAjax;

        aj.body = newAjaxAnn;

        aj.generateRequest();
    },
    _addAnnResponse(e) {
      const response = e.detail.response;
      const newAnn = {
          name: '',
          id: response.id,
          label: response.label,
          description: response.description,
          start: response.start,
          duration: response.end - response.start,
          end: response.end,
          cStart: null,
          cEnd: null,
          selected: true,
          channelIds: response.channelIds,
          allChannels: false,
          layer_id: response.layerId,
          userId: response.userId
      };
      if (response.linkedPackage) {
        newAnn.linkedPackage = response.linkedPackage
      }
      // Check if user is in userMap
      const userMap = this.parent.parent.userMap;
      const userProfile = R.path(['state', 'profile'])(this);
      if (userMap && !R.hasIn(response.userId, userMap) && userProfile) {
        const userObj = {};
        userObj[userProfile.id] = userProfile;
      }
      // Check if all channels are selected
      if (newAnn.channelIds.length >= this.vuex.viewer.viewerChannels.length) {
          newAnn.allChannels = true;
      }
      // Find layer
      let curLIndex = 0;
      for (let i = 0; i < this.vuex.viewer.viewerAnnotations.length; i++) {
          if (this.vuex.viewer.viewerAnnotations[i].id === response.layerId) {
              curLIndex = i;
              break;
          }
      }

      this.$store.dispatch('viewer/createAnnotation', newAnn).then(() => {

        this.sortAnns(this.vuex.viewer.viewerAnnotations[curLIndex].annotations);

        // let the viewer know an annotation has been added
        this.annotationChange(response.layerId);
        this.selectedAnns = [newAnn];

        this.render();
        // open window
        const annotationInfo = {
          annotation: newAnn,
          layers: this.vuex.viewer.viewerAnnotations,
          selectedLabelId: response.label,
          selectedLayerId: response.layerId,
          isCreating: true
        };
        this.fire('active-viewer-action', {
          method: 'openAnnotationWindow',
          payload: annotationInfo
        });
      });
    },
    /**
     * handle layers api success response
     * @params {Object} detail
     */
    _getLayerResponse(detail) {
        // reset layers list
        this.set('annLayers', [])

        // If there is no layer present, create a default layer.
        if (detail.response.results.length === 0) {
            const payload = {
                name: 'Default',
                color: '#18BA62',
                description: 'Default Annotation Layer'
            };
            this.viewer.domHost.fire('create-layer', { layer: payload, firstLayer: true })
        } else {
            // get the layers from the response
            for (let i = 0; i< detail.response.results.length; i++) {
              let layerColor = detail.response.results[i].color
              if (!layerColor) {
                layerColor = this.defaultColors[i%this.defaultColors.length];
              }
              const layer = {
                id: detail.response.results[i].id,
                name: detail.response.results[i].name,
                description: detail.response.results[i].description,
                visible: true,
                selected: false,
                annotations: [],
                color: this.hexToRgbA(layerColor, 0.7),
                hexColor: layerColor,
                bkColor: this.hexToRgbA(layerColor, 0.15),
                selColor: this.hexToRgbA(layerColor, 0.9)
              }

              this.push('annLayers', layer);
            }
            this.$store.dispatch('viewer/setAnnotations', this.annLayers).then(() => {
              this.fire('get-scrubber-annotations')
              this.setActiveLayer(this.annLayers[0]);
            })
          }


          this.set('annLayerInfo', detail.response.results);

          return Promise.resolve()
    },
    _createLayerResponse: function(e, detail) {
        const layer = {
            id: detail.response.id,
            name: detail.response.name,
            description: detail.response.description,
            visible: true,
            selected: true,
            annotations: [],
            hexColor: detail.response.color,
            color: this.hexToRgbA(detail.response.color, 0.7),
            bkColor: this.hexToRgbA(detail.response.color, 0.15),
            selColor: this.hexToRgbA(detail.response.color, 0.9)
        }

        this.$store.dispatch('viewer/createLayer', layer);

        this.annotationChange(detail.response.id);
    },
    _getAnnResponse(e) {
        // const userMap = R.pathOr([], ['users'], e);
        const linkedPackages = R.propOr({}, 'linkedPackages', e)
        let resp = R.pathOr([], ['annotations', 'results'], e);

        // Set requested range to last annstart.
        if (resp.length >= this.constants['LIMITANNFETCH']) {
            // find max start time
            let maxStart = 0;
            for (let j =0; j< resp.length; j++) {
                if (resp[j].start > maxStart) {
                    maxStart = resp[j].start;
                }
            }
            // find range
            for (let i = 0; i < this.cachedAnnRange.length; i++) {
                if (this.cachedAnnRange[i].end > maxStart && this.cachedAnnRange[i].start < maxStart) {
                    this.cachedAnnRange[i].end = maxStart;
                    break;
                }
            }
        }

        const isViewingMontage = this.vuex.viewer.viewerMontageScheme !== 'NOT_MONTAGED'

        if (resp.length > 0) {
            const annotations = []
            for (let i = 0; i < resp.length; i++) {
                const curAnn = resp[i];
                if (this.annotations.indexOf(curAnn.id) >= 0) {
                    // annotation already exists
                    continue;
                }
                const newAnn = {
                  name:'',
                  id: curAnn.id,
                  label: curAnn.label,
                  description: curAnn.description,
                  start: curAnn.start,
                  duration: curAnn.end - curAnn.start,
                  end: curAnn.end,
                  cStart: null,
                  cEnd: null,
                  selected: false,
                  channelIds: curAnn.channelIds,
                  allChannels: false,
                  layer_id: curAnn.layerId,
                  userId: curAnn.userId
                };
                if (curAnn.linkedPackage) {
                  const pkgId = curAnn.linkedPackage
                  newAnn.linkedPackage = R.pathOr('', ['content', 'id'], linkedPackages[pkgId])
                  newAnn.linkedPackageDTO = linkedPackages[pkgId]
                }
                // Check if all channels are selected
                if (!isViewingMontage && newAnn.channelIds.length === this.vuex.viewer.viewerChannels.length) {
                    newAnn.allChannels = true;
                } else if (isViewingMontage && newAnn.channelIds.length > this.vuex.viewer.viewerChannels.length) {
                    newAnn.allChannels = true
                }
                 // Find layer
                let curLIndex = null;
                for (let j = 0; j < this.vuex.viewer.viewerAnnotations.length; j++) {
                    if (this.vuex.viewer.viewerAnnotations[j].id === curAnn.layerId) {
                        curLIndex = j;
                        break;
                    }
                }
                if (curLIndex === null) {
                    const newLayer = {
                      id: this.vuex.viewer.viewerAnnotations.length,
                      color: null,
                      visible: true,
                      selected: false,
                      annotations:[],
                      userId: curAnn.userId
                    }
                    this.$store.dispatch('viewer/createLayer', newLayer);
                    curLIndex = this.vuex.viewer.viewerAnnotations.length -1;
                }
                annotations.push(newAnn);
            }
            // get layers
            this.vuex.viewer.viewerAnnotations.forEach(layer => {
              // get annotations for layer
              const layerAnns = layer.annotations;
              const filteredAnns = annotations.filter(ann => layer.id === ann.layer_id);
              layer.annotations = layerAnns.concat(filteredAnns);
              // get all annotations per layer
              this.$store.dispatch('viewer/updateLayer', layer);
            });
        } else {
          // if no annotations exist, force render layers in side panel
          // just to be safe
          this.fire('render-side-panel-layers')
        }
        this.viewer.renderAll(100)
    },

    /**
     * remove original annotation from layers
     * @param {Number} layerIdx
     * @param {Object} ann
     */
    _removeAnnFromLayer: function(layerIdx, ann) {
      const layerAnnotations = this.annLayers && this.annLayers[layerIdx];

      if (!layerAnnotations) {
        return;
      }
      const updatedAnnotations = layerAnnotations.annotations.filter(layerAnn => layerAnn.id !== ann.id);
      this.set(`annLayers.${layerIdx}.annotations`, updatedAnnotations);

      this.fire('updateLayer', updatedAnnotations)
    },

    /**
     * get index of layer for original annotation placement
     * @param {Number} annId
     * @param {Array} annLayers
     */
    _getOriginalLayerIndex: function(annId, annLayers) {
      return annLayers.reduce((acc, layer, idx) => {
          const annIndex = R.findIndex(R.propEq('id', annId), layer.annotations)
          if (annIndex >= 0) {
            acc = idx;
          }
          return acc;
        }, -1);
    },

    _updateAnnResponse(e, detail) {
        // update annotations
        const response = detail.response;
        const curLayerIdx = this._getOriginalLayerIndex(response.id, this.vuex.viewer.viewerAnnotations);
        const newLayerIdx = R.findIndex(R.propEq('id', response.layerId), this.vuex.viewer.viewerAnnotations);

        const annIdx = R.findIndex(R.propEq('id', response.id), this.vuex.viewer.viewerAnnotations[curLayerIdx].annotations);
        const currentAnnotation = this.vuex.viewer.viewerAnnotations[curLayerIdx].annotations[annIdx];
        const updatedAnn = {
          name: response.name,
          description: response.description,
          layer_id: response.layerId,
          label: response.label
        };
        if (response.linkedPackage) {
          updatedAnn.linkedPackage = response.linkedPackage
        }
        const state = Object.assign({}, currentAnnotation, updatedAnn);

        // remove linkedPackage property from state if it was removed by user
        if (!response.linkedPackage && state.linkedPackage) {
          delete state.linkedPackage
          delete state.linkedPackageDTO
        }

        // remove original annotation from layers
        if (newLayerIdx !== curLayerIdx) {
          this._removeAnnFromLayer(curLayerIdx, response);

          // Add annotation to new layer
          this.$store.dispatch('viewer/createAnnotation', state).then(() => {
            this.setUpdatedAnnotations()
          })
        } else {
          this.$store.dispatch('viewer/updateAnnotation', state).then(() => {
            this.setUpdatedAnnotations()
          })
        }

        // let the viewer know an annotation has been changed
        this.annotationChange(detail.response.layerId);
        this.setActiveLayer(this.vuex.viewer.viewerAnnotations[newLayerIdx]);
    },
    setUpdatedAnnotations: function() {
      // Sort rendered annotations
      const activeLayer = this.$store.getters['viewer/getViewerActiveLayer']();
      this.sortAnns(activeLayer.annotations);

      this.render();
    },

    renderAnnotationBox: function(detail) {
        const iCanvas = this.parent.$.iArea;
        const ctx = iCanvas.getContext('2d');
        ctx.setTransform(this.parent.pixelRatio, 0, 0, this.parent.pixelRatio, 0, 0);


        const annotationHeight = this.constants['ANNOTATIONLABELHEIGHT'];
        const halfAnnotationHeight = (annotationHeight/2) |0;


        // Find active layer
        let curLIndex = null;
        for (let i=0; i<this.vuex.viewer.viewerAnnotations.length; i++) {
            if (this.vuex.viewer.viewerAnnotations[i].selected) {
                curLIndex = i;
                break;
            }
        }

        // No active Layers
        if (curLIndex === null) {
            return;
        }

        ctx.save();
        ctx.clearRect(0, 0, this.parent.cWidth, this.parent.cHeight);
        ctx.lineWidth = 1;

        // Determine if the user is adding annotation to specific channels
        const selectedChannels = this.$store.getters['viewer/viewerSelectedChannels']
        const allChannels = selectedChannels.length === this.vuex.viewer.viewerChannels.length || selectedChannels.length === 0

        if (allChannels) {
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            let xStart = this.startDragCoordPx;
            ctx.fillRect(xStart, 0, detail.dx, this.parent.pHeight);

            ctx.fillStyle = this.vuex.viewer.viewerAnnotations[curLIndex].color;
            ctx.strokeStyle = ctx.fillStyle;

            let lblStart = xStart -1;
            let lblEnd = detail.dx +2;
            if (detail.dx < 0) {
                lblStart = xStart +1;
                lblEnd = detail.dx-2;
            }

            ctx.fillRect(lblStart, 0, lblEnd, annotationHeight);

            ctx.setLineDash([5, 5, 5, 5]);
            ctx.beginPath();
            ctx.moveTo(xStart, annotationHeight);
            ctx.lineTo(xStart, this.parent.pHeight );
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(xStart+detail.dx, annotationHeight);
            ctx.lineTo(xStart+detail.dx, this.parent.pHeight );
            ctx.stroke();
        } else {

            let minOffset = this.parent.cHeight | 0;
            let maxOffset = 0;
            const channelConfig = this.vuex.viewer.viewerChannels;

            ctx.fillStyle = this.vuex.viewer.viewerAnnotations[curLIndex].color;
            ctx.strokeStyle=ctx.fillStyle;

            let xStart = this.startDragCoordPx;

            let lblStart = xStart -1;
            let lblEnd = detail.dx +2;
            if (detail.dx < 0) {
                lblStart = xStart +1;
                lblEnd = detail.dx-2;
            }

            for (let ch=0; ch< channelConfig.length; ch++) {
                const curChannelView = channelConfig[ch];
                if(curChannelView.selected && curChannelView.visible) {
                    const channelOffset = curChannelView.rowBaseline |0;
                    if (channelOffset < minOffset) { minOffset = channelOffset; }
                    if (channelOffset > maxOffset) { maxOffset = channelOffset; }

                    ctx.fillRect(lblStart, channelOffset - halfAnnotationHeight, lblEnd, annotationHeight);

                }
            }

            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.setLineDash([5, 5, 5, 5]);

            ctx.fillRect(xStart -1, minOffset+halfAnnotationHeight,
                    detail.dx +2, maxOffset-minOffset -annotationHeight);
            ctx.beginPath();
            ctx.moveTo(xStart, minOffset +halfAnnotationHeight);
            ctx.lineTo(xStart, maxOffset-halfAnnotationHeight );
            ctx.moveTo(xStart+detail.dx, minOffset +halfAnnotationHeight);
            ctx.lineTo(xStart+detail.dx, maxOffset -halfAnnotationHeight);
            ctx.stroke();


        }
        ctx.restore();
    },
    unfocusElements: function() {
        if (this.focusedAnn !== null) {
            this.focusedAnn = null;
            this.render();
        }
    },
    unSelectAnnotations: function(layer, update) {
        if (layer !== null) {
            for (let i=0; i< layer.annotations.length; i++) {
                layer.annotations[i].selected = false;
            }
        } else{
            for (let l=0; l<this.vuex.viewer.viewerAnnotations.length; l++) {
                const layer2 = this.vuex.viewer.viewerAnnotations[l];
                for (let i2 =0; i2< layer2.annotations.length; i2++) {
                    layer2.annotations[i2].selected = false;
                }
            }
        }

        if (update) {
            this.render();
        }
    },
    onTap: function(e, pointerMode) {
      const annotationPopover = this.parent.$.annotationPopover
      annotationPopover.style.opacity = 0
      annotationPopover.style.display = 'none'

        switch(pointerMode) {
            case 'annSelect':
                if (this.focusedAnn) {
                  this.focusedAnn.selected = !this.focusedAnn.selected;
                }
                if (this.focusedAnn && this.focusedAnn.selected) {
                  const append = e.detail.sourceEvent.metaKey;
                  this.selectAnnotation(this.focusedAnn, append);

                } else {
                  this.unselectAnnotation(this.focusedAnn);
                }
                break;
            case 'point':
                this.unselectAllAnnotations();
                break;


        }
    },
    selectAnnotation: function(ann, append) {
        this.viewer.fire('view-annotation', {
          id: ann.id
        });

        ann.selected = true;
        if (append) {
            this.push('selectedAnns', ann);
        } else {
            for (let i=0; i< this.selectedAnns.length; i++) {
                this.selectedAnns[i].selected = false;
            }
            this.set('selectedAnns', [ann])
        }

        this.render();
    },
    unselectAnnotation: function(ann) {
        if (!ann) {
          return
        }
        ann.selected = false;
        const index = this.selectedAnns.indexOf(ann);
        this.splice('selectedAnns', index, 1);

        this.render();
    },
    selectAllinActiveLayer: function() {
        const activeLayer = this.$store.getters['viewer/getViewerActiveLayer']();

        for (let i=0; i< activeLayer.annotations.length; i++) {
            if (!activeLayer.annotations[i].selected) {
                activeLayer.annotations[i].selected = true;
                this.push('selectedAnns', activeLayer.annotations[i]);
            }
        }

        this.render();
    },
    unselectAllAnnotations: function() {
        for (let i=0; i< this.selectedAnns.length; i++) {
            this.selectedAnns[i].selected = false;
        }
        this.selectedAnns = [];
        this.render();
    },
    deleteActiveLayer: function() {
      let activeLayer = null;
      let activeLayerIdx = null;
      for (let j=0; j<this.vuex.viewer.viewerAnnotations.length; j++) {
          if (this.vuex.viewer.viewerAnnotations[j].selected) {
              activeLayer = this.vuex.viewer.viewerAnnotations[j];
              activeLayerIdx = j;
          }
      }
      // remove all annotations from selectedAnns
      if (this.selectedAnns) {
          for (let i= (this.selectedAnns.length-1); i>=0; i--) {
              if (this.selectedAnns[i].layer === activeLayer) {
                  this.splice('selectedAnns', i, 1);
              }
          }
      }
      // remove focusAnn if in layer
      if (this.focusedAnn && this.focusedAnn.layer === activeLayer) {
          this.focusedAnn = null;
      }
      // Remove layer
      const ajax = this.$.deleteLayerAjax;
      const apiUrl = this.vuex.config.apiUrl
      ajax.url = `${apiUrl}/timeseries/${this.data.id}/layers/${activeLayer.id}?api_key=${this.vuex.userToken}`;
      ajax.generateRequest();

      // Delete layer
      this.$store.dispatch('viewer/deleteLayer', activeLayer)

      const newActiveLayer = this.vuex.viewer.viewerAnnotations[0]
      newActiveLayer.selected = true
      this.$store.dispatch('viewer/updateLayer', newActiveLayer).then(() => {
        this.render();
      })

      this.annotationChange(activeLayer.id, 'DELETE');
    },
    initAnnotations: function() {
        const aj = this.$.getLayersAjax;
        aj.generateRequest().completes
          .then(payload => this._getLayerResponse(payload))
          .then(() => {
            this.checkAnnotationRange(this.parent.start, this.parent.start + this.parent.duration);
          })
    },
    annotationChange: function(layerId, type = 'UPDATE') {
      this.fire('annotation-change', {
        layerId,
        type
      });
    }

  }
</script>
