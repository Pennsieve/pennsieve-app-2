<link rel="import" href="../../../../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../../../../bower_components/paper-button/paper-button.html">

<link rel="import" href="../bf-query-builder-title/bf-query-builder-title.html">
<link rel="import" href="../bf-query-filter/bf-query-filter.html">
<link rel="import" href="../../../../../vendor-scripts.html">

<link rel="import" href="../../../../../styles/blackfynn/main.html">
<link rel="import" href="../../../../../styles/blackfynn/grid.html">
<link rel="import" href="../../../../../styles/blackfynn/explore.html">
<!--
`bf-query-builder`
A component designed to create and save a concepts query.

@demo demo/index.html
-->

<dom-module id="bf-query-builder">
  <template>
    <style include="blackfynn-main-styles"></style>
    <style include="bf-grid-styles"></style>
    <style include="bf-explore-styles"></style>
    <style>
      :host {
        display: block;
      }
      .filter-header {
        background-color: #F7F7F7;
        border-top: solid 1px var(--cortex);
        border-bottom: solid 1px var(--cortex);
        height: 35px;
        margin: 0 0 20px 0;

        @apply(--layout-horizontal);
        @apply(--layout-center);
      }
      h2 {
        font-size: 13px;
        margin: 0;

        @apply(--layout-flex);
      }
      h3 {
        color: #71747C;
        font-size: 13px;
        line-height: 15px;
        margin-bottom: 20px;
      }
      a {
        color: var(--dopamine);
        padding-bottom: 1px;
        border-bottom: solid 1px var(--dopamine);
        text-decoration: none;
      }
      a:hover {
        color: var(--dopamine);
        border-bottom: none;
      }
      .control-link {
        color: var(--glial);
        padding-bottom: 0;
        border-bottom: none;
      }
      bf-input {
        margin: 0 20px 0 0;
      }
      paper-button {
        margin: 20px 10px 0 0;
      }
      .loading-wrap {
        width: 100%;
        @apply(--layout-horizontal);
        @apply(--layout-center-center);
      }
    </style>

    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <bf-query-builder-title query-title="{{queryTitle}}"></bf-query-builder-title>
        </div>
      </div>
    </div>

    <div class="filter-header">
      <div class="container">
        <div class="row">
          <div class="col-sm-6">
            <h2>Filters</h2>
          </div>
          <div class="col-sm-6">
            <!-- <a href="#hideFilters" class="control-link" on-tap="toggleFilters">
              <template is="dom-if" if="[[!_filtersHidden]]">Hide</template>
              <template is="dom-if" if="[[_filtersHidden]]">Show</template>
            </a> -->
          </div>
        </div>
      </div>
    </div>

    <div class="container" hidden="[[_filtersHidden]]">
      <div class="row">
        <div class="col-sm-12">
          <div hidden$="[[!hasTopology]]">
            <h3 hidden$="[[!hasInitialConcept]]">Exploring data by <strong>[[concept.name]]</strong></h3>
            <template is="dom-repeat" id="queryBuilder" items="{{queryFilters}}">
              <bf-query-filter
                concepts="[[concepts]]"
                selected-concept="{{item.selectedConcept}}"
                related-fields="{{item.relatedFields}}"
                selected-related-field="{{item.selectedRelatedField}}"
                operators="[[operators]]"
                selected-operator="{{item.selectedOperator}}"
                value-to-compare="{{item.valueToCompare}}"
                index="[[index]]"></bf-query-filter>
            </template>
            <paper-button class="light-gradient" noink on-tap="addFilter">Add Filter</paper-button>
            <paper-button class="search-button light" noink on-tap="runSearch">Search</paper-button>
          </div>
        </div>
      </div>
    </div>
  </template>

  <script>
    Polymer({

      is: 'bf-query-builder',

      properties: {
        /**
         * Title of query
         */
        queryTitle: {
          type: 'String'
        },
        /**
         * List of available operators
         */
         operators: {
          type: Array,
          value: function() {
            return [
              {
                label: 'eq',
                value: 'eq'
              },
              {
                label: 'neq',
                value: 'neq'
              }
            ];
          }
        },
        /**
         * Current query
         */
         query: {
          type: Object,
          value: function() {
            return {};
          }
        },
        /**
         * List of filter concepts
         */
         concepts: {
          type: Array,
          value: function() {
            return [];
          }
        },
        /**
         * List of concept related fields
         */
         relatedFields: {
          type: Array,
          value: function() {
            return [];
          }
        },
        /**
         * List of filter components and their properties
         */
         topology: {
          type: Array,
          value: function() {
            return [];
          }
        },
        /**
         * List of saved queries
         */
         queryFilters: {
          type: Array,
          value: function() {
            return [];
          },
          notify: true
        },
        /**
         * Tracks whether or not user is adding a filter
         */
         isAddingFilters: {
          type: Boolean,
          value: false
        },
        /**
         * Tracks whether or not filters are hidden
         */
        _filtersHidden: {
          type: Boolean,
          value: false
        },
        /**
         * Tracks whether or not there is an initialConcept
         */
         hasInitialConcept: {
          type: Boolean,
          computed: '_computeHasInitialConcept(concept.name, concept.name.length)'
        },
        /**
        * Computes whether or not topology exists for concept instance
        */
        hasTopology: {
          type: Boolean,
          computed: '_computeHasTopology(topology.length, concepts.length)'
        },
        /**
         * current offset for search results
         */
        offset: {
          type: Number
        },
        /**
         * current limit for search results
         */
         limit: {
          type: Number
        },
      },

      listeners: {
        'remove-concept-filter': '_handleRemoveFilter',
        'update-related-fields': '_handleRelatedFieldsUpdate',
        'rename-concept-query': '_handleRenameConceptQuery'
      },

      observers: [
        '_watchTopology(topology.length, topology)',
        '_watchQueryFilters(queryFilters.length)'
      ],

      /**
        * Computes topology results for concept instances
        * @param {Number} topologyLength
        * @param {Boolean}
        */
      _computeHasTopology: function(topologyLength, conceptsLength) {
        return topologyLength > 0 && conceptsLength > 0;
      },

      /**
       * Observer for topology changes
       * @param {Number} topologyLength
       * @param {Array} topology
       */
      _watchTopology: function(topologyLength, topology) {
        const concepts = this.getConcepts(topology);
        this.set('concepts', concepts);
      },

      /**
       * Observer for queryFilter changes
       */
      _watchQueryFilters: function() {
        this.fire('notify-resize');
      },

      /**
       * Handles rename-concept-query event
       * @param {Object} evt
       * @param {Object} detail
       */
       _handleRenameConceptQuery: function(evt, detail) {
          this.buildQuery();
          this.fire('save-concept-query', {
            name: detail.title,
            query: this.query
          });
      },

      /**
       * Toggles filters visibility
       * @param {Object} evt
       */
      toggleFilters: function(evt) {
        evt.preventDefault();
        this.set('_filtersHidden', !this._filtersHidden);
      },

      /**
       * Returns a list of concept types given a list of concepts
       * @param {Array}
       * @returns {Array}
       */
      getConcepts: function(list) {
        if (!list || list.length === 0) {
          return;
        }
        const listWithProps = list.filter(li => li.properties.length > 0);
        const concepts = R.pluck('conceptType', listWithProps);

        return concepts.map(concept => {
          return {
            label: concept,
            value: concept
          }
        });
      },

      /**
       * Returns list of concept properties given a concept and a list of concepts
       * @param {String}
       * @param {Array}
       * @returns {Array}
       */
      getRelatedFields: R.compose(
        R.propOr([], 'properties'),
        R.useWith(
          R.find,
          [R.propEq('conceptType')]
        )
      ),

      /**
       * Returns the first value within concept properties list
       * @param {Array}
       * @returns {String}
       */
      getSelectedValue: R.compose(
        R.propOr('', 'value'),
        R.head,
        R.defaultTo([{}])
      ),

      /**
       * Handles update-related-fields custom event
       * @param {Object} evt
       * @param {Object} detail
       */
      _handleRelatedFieldsUpdate: function(evt, detail) {
        if (!detail.conceptType) {
          return;
        }
        const rawData = this.getRelatedFields(detail.conceptType, this.topology);
        const relatedFields = rawData.map(field => {
          return {
            label: field.name,
            value: field.value ? field.value : field.name
          }
        });
        // update query filters with concept
        const bfQueryFilters = Polymer.dom(this.root).querySelectorAll('bf-query-filter');
        bfQueryFilters[detail.index].set('relatedFields', relatedFields);

        const selectedValue = this.getSelectedValue(relatedFields);
        bfQueryFilters[detail.index].$.relatedFieldsMenu.set('selectedValue', selectedValue);
      },

      /**
       * Add a new filter to the query builder
       */
      addFilter: function() {
        const newFilter = [{}];
        this.set('queryFilters', this.queryFilters.concat(newFilter));
      },

      /**
       * Handles remove-concept-filter event
       * @param {Object} evt
       */
       _handleRemoveFilter: function(evt) {
        this.splice('queryFilters', evt.detail, 1);
      },

      /**
       * Builds filters array for query
       * @param {Object} filter
       */
      _buildFilters: function(filter) {
        return {
          'key': filter.selectedRelatedField,
          'predicate': {
            'operation': filter.selectedOperator,
            'value': filter.valueToCompare
          }
        };
      },

      /**
       * Builds joins array for query
       * @param {Object} filter
       */
       _buildJoins: function(filter) {
        let targetType = {
          concept: {
            type: filter.selectedConcept
          }
        };
        if (filter.selectedRelatedField === 'package') {
          targetType = {
            proxy: {
              type: 'package'
            }
          }
        }
        return {
          targetType,
          filters: [this._buildFilters(filter)]
        };
      },

      /**
       * Builds the search query
       */
      buildQuery: function() {
        // get all bf-query-filter components
        const filters = Polymer.dom(this.root).querySelectorAll('bf-query-filter');
        const buildFilters = this._buildFilters.bind(this);
        const buildJoins = this._buildJoins.bind(this);

        const conceptFilters = filters.filter(fil => fil.selectedConcept === this.concept.name).map(buildFilters);
        const relatedFilters = filters.filter(fil => fil.selectedConcept !== this.concept.name).map(buildJoins);

        this.set('query', {
          type: {
            concept: {
              type: this.concept.name
            }
          },
          filters: conceptFilters,
          joins: relatedFilters,
          offset: this.offset,
          limit: this.limit
        });
      },

      /**
       * Executes search query by applying filters
       */
      runSearch: function() {
        this.buildQuery();
        this.fire('run-search', this.query);
      },

      /**
       * Computes whether or not an initialConcept is present
       * @param {String} initialConcept
       * @param {Boolean}
       */
       _computeHasInitialConcept(initialConcept, initialConceptLength) {
        return initialConcept && initialConceptLength > 0;
      },

    });
  </script>
</dom-module>
