<link rel="import" href="../../../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../../../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../../../../bower_components/iron-a11y-keys/iron-a11y-keys.html">

<link rel="import" href="../../shared/bf-input/bf-textarea.html">
<link rel="import" href="../../shared/bf-select-menu/bf-select-menu.html">
<link rel="import" href="../../shared/item-icon-behavior.html">
<link rel="import" href="../../shared/vuex-behavior/vuex-behavior.html">
<link rel="import" href="../../shared/bf-dialog/bf-dialog.html">

<link rel="import" href="../../../../styles/blackfynn/main.html">
<link rel="import" href="../../../../styles/blackfynn/icons.html">
<link rel="import" href="../../../../styles/blackfynn/data-item.html">

<dom-module id="bf-timeseries-annotation-window">
  <template>
    <style include="blackfynn-main-styles"></style>
    <style include="bf-data-item-styles"></style>
    <style type="text/css">
      :host {
        display: block;
        box-sizing: border-box;
        --iron-icon-height: 24px;
        --iron-icon-width: 24px;
      }
      .wrapper {
        @apply(--layout-horizontal);
        @apply(--layout-flex);
        @apply(--layout-wrap);
      }
      .menu {
        flex: 0 0 50%;
      }
      bf-dialog {
        width: 100%;
        max-width: 630px;
        overflow: hidden;
      }
      .select-wrapper {
        border-left: 5px solid var(--dopamine);
      }
      #layerSelect {
        margin: 0 5px 10px 0;
      }
      #labelSelect {
        margin: 0 0 10px 5px;
      }
      .button-wrapper {
        @apply(--layout-horizontal);
        @apply(--layout-justified);
        @apply(--layout-center);
      }
      .channelsSelected {
        margin-right: 20px;
      }
      .channels-icon {
        border: 1px solid var(--light-gray);
        border-radius: 2px;
        color: var(--light-gray);
        margin-right: 5px;
      }
      paper-button {
        background: linear-gradient(180deg, var(--white-matter) 0%, #F9F9F9 100%);
        border: 1px solid #D3D5DA;
        border-radius: 5px;
        color: var(--glial);
        cursor: pointer;
        font-size: 14px;
        line-height: 20px;
        margin: 0;
        outline: none;
        padding: 7px 45px;
        text-transform: none;
      }
      .cancel {
        margin-right: 5px;
        padding: 7px 25px;
      }
      .save {
        background: linear-gradient(180deg, var(--dopamine) 0%, #1F55EA 100%) !important;
        border-color: transparent !important;
        color: #fff;
        padding: 7px 15px;
      }
      .remove-attachment-wrapper {
        display: flex;
        margin-top: 16px;
        align-items: center;
      }
      .remove-attachment {
        color: var(--dopamine);
        cursor: pointer;
        display: flex;
      }
      .icon-wrap {
        display: flex;
        margin-right: 8px;
      }
      .icon-item {
        margin-right: 8px;
      }
      .package-name {
        display: flex;
        align-self: center;
      }
      #description {
        margin-bottom: 10px;
      }
      .checkbox-wrapper {
        padding: 0 4px;
      }
      .attach-package {
        position: absolute;
        opacity: 0;
        cursor: pointer;
        width: auto;
        z-index: 1;
      }
      .attach-package-label {
        cursor: pointer;
        position: relative;
        left: 24px;
        vertical-align: middle;
      }
      .checkmark {
        cursor: pointer;
        position: absolute;
        height: 16px;
        width: 16px;
        background-color: var(--white-matter);
        border: 1px solid var(--light-gray);
        border-radius: 3px;
        box-shadow: 0 1px 0 0 rgba(22,29,37,0.05);
      }
      .checkmark:after {
        content: "";
        display: none;
        position: absolute;
      }
      .checkmark:after {
        border: solid var(--white-matter);
        border-width: 0 2px 2px 0;
        height: 9px;
        left: 5px;
        top: 1px;
        -webkit-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
        transform: rotate(45deg);
        width: 5px;
      }
      .attach-package:checked ~ .checkmark:after {
        display: block;
      }
      .attach-package:checked ~ .checkmark {
        background-color: var(--dopamine);
        border-color: var(--dopamine);
      }
      h2 {
        margin: 20px 30px 30px 30px;
      }
    </style>

    <bf-dialog id="dialog" opened="{{opened}}" processing="[[processing]]">
      <h2 slot="heading">[[_heading]]</h2>

      <div slot="body">
        <div class="wrapper">
          <div class="menu">
            <div class="menu select-wrapper" style="border-color: [[_layerColor]]">
              <bf-select-menu
                id="layerSelect"
                selected-value="{{selectedLayerId}}"
                items="[[_layers]]"></bf-select-menu>
            </div>
          </div>
          <div class="menu">
            <bf-select-menu
              class="menu"
              id="labelSelect"
              selected-value="{{selectedLabelId}}"
              items="[[_labels]]"></bf-select-menu>
          </div>
        </div>
        <bf-textarea
          label="Add a description."
          hide-label
          placeholder="Add a description."
          invalid="[[!isFormValid]]"
          value="{{description}}"
          id="description"
          rows="2"
          max-rows="4"></bf-textarea>
          <template is="dom-if" if="[[hasAnnPackage]]">
            <div class="remove-attachment-wrapper">
              <div class="icon-wrap">
                <img src$="[[_computeIcon(annotation.linkedPackageDTO)]]" alt="icon" class="svg-icon icon-item">
                <span class="package-name">[[annPkgTitle]]</span>
              </div>
              <span class="remove-attachment" on-tap="removeAttachment">Remove Attachment</span>
            </div>
          </template>
          <template is="dom-if" if="[[!hasAnnPackage]]">
            <div class="checkbox-wrapper" on-tap="onAttachPackage">
              <input type="checkbox" class="attach-package" id="attachPackageInput">
              <div class="checkmark"></div>
              <label for="attachPackageInput" class="attach-package-label">Attach an existing file</label>
            </div>
          </template>
      </div>

      <div slot="buttons">
        <div class="button-wrapper">
          <div class="channelsSelected">
            <template is="dom-if" if="[[allChannelsSelected]]">
              <iron-icon class="channels-icon" icon="blackfynn:global"></iron-icon> Adding to All Channels
            </template>
            <template is="dom-if" if="[[!allChannelsSelected]]">
              <iron-icon class="channels-icon" icon="blackfynn:selection"></iron-icon> Adding to [[selectedChannels]] Selected Channels
            </template>
          </div>
          <div class="buttons">
            <paper-button
              class="cancel"
              noink
              hidden$="[[processing]]"
              on-tap="_closeModal">Cancel</paper-button>
            <paper-button
              class="save"
              noink
              dialog-confirm$="[[_hasDescription]]"
              hidden$="[[processing]]"
              on-tap="submitForm">[[_buttonText]]</paper-button>
          </div>
        </div>
      </div>
    </bf-dialog>

    <iron-a11y-keys
      keys="enter"
      target="[[_this]]"
      on-keys-pressed="submitForm"></iron-a11y-keys>
  </template>

  <script>

    Polymer({
      is: 'bf-timeseries-annotation-window',

      behaviors: [
        Blackfynn.ItemIconBehavior,
        Blackfynn.VuexBehavior
      ],

      properties: {
        /**
         * Determines whether annotation should be applied to all channels
         */
        allChannelsSelected: {
          type: Boolean,
          computed: '_computeAllChannelsSelected(selectedChannels, channels.length)'
        },
        /**
         * Determines number of selected channels
         */
        selectedChannels: {
          type: Boolean,
          computed: '_computeSelectedChannels(channels.*)'
        },
        /**
         * Annotation the user is adding
         */
        annotation: {
          type: Object,
          value: function() {
            return {}
          }
        },
        /**
         * Annotation description
         */
        description: {
          type: String,
          value: '',
        },
        /**
         * Compute if the user has entered a label
         */
        _hasDescription: {
          type: Boolean,
          computed: '_computeHasDescription(description)'
        },
        /**
         * This component
         */
        _this: {
          type: Object,
          value: function() {
            return this;
          }
        },
        /**
         * If the request is being processed
         */
        processing: {
          type: Boolean,
          value: false
        },
        /**
         * Layer selected from the select menu
         */
        selectedLayerId: {
          type: Number
        },
        /**
         * Layers
         */
        layers: {
          type: Array,
          value: function() {
            return [];
          }
        },
        /**
         * Computed layers list for the select menu
         */
        _layers: {
          type: Array,
          computed: '_computeLayers(layers.*)'
        },
        /**
         * Compute color for the selected layer
         */
        _layerColor: {
          type: String,
          computed: '_computeLayerColor(selectedLayerId, layers.*)'
        },
        /**
         * Label selected from the select menu
         */
         selectedLabelId: {
          type: Number
        },
        /**
         * default labels
         */
         defaultLabels: {
           type: Array,
           value: function() {
             return ['Event', 'Artifact', 'Seizure', 'Mark', 'Stim On', 'Stim Off', 'Start', 'Stop'];
           }
        },
        /**
         * Computed channels list for the select menu
         */
        _labels: {
          type: Array,
          computed: '_computeLabels(defaultLabels)'
        },
        /**
         * If the user is creating an annotation
         */
        isCreating: {
          type: Boolean,
          value: true
        },
        /**
         * Compute heading
         */
        _heading: {
          type: String,
          computed: '_computeHeading(isCreating)'
        },
        /**
         * Compute button text
         */
        _buttonText: {
          type: String,
          computed: '_computeButton(isCreating)'
        },
        /**
         * List of channels
         */
        channels: {
          type: Array,
          value: function() {
            return [];
          }
        },
        isFormValid: {
          type: Boolean,
          value: true
        },
        /**
        * annotation package title
        */
        annPkgTitle: {
          type: String,
          computed: '_computeAnnPkgTitle(annotation)'
        },
        /**
        * checks if annotation has a linked package
        */
        hasAnnPackage: {
          type: Boolean,
          computed: '_computeHasAnnPackage(annotation.*)'
        },
        /**
         * Whether or not the user wants to attach a package
        */
        attachPackage: {
          type: Boolean,
          value: false
        },
        /**
        * Whether or not the modal is a confirmed state
        */
        confirmed: {
          type: Boolean,
          value: false
        },
        /**
        * Whether or not the modal is a canceled state
        */
        canceled: {
          type: Boolean,
          value: false
        }
      },

      listeners: {
        'iron-overlay-opened': '_onOpen',
        'iron-overlay-closed': '_onClose'
      },
      /**
      * Compute the annotation package title
      * @param {Object} annotation
      */
      _computeAnnPkgTitle: function(annotation) {
        const pkgTitle = R.pathOr('', ['linkedPackage', 'content', 'name'], annotation)
        return pkgTitle
      },
      /**
       * Check if annotation has a linkedPackage
       * @param {Object} annotation
       */
      _computeHasAnnPackage: function(annotation) {
        const pkgId = R.pathOr('', ['base', 'linkedPackage'], annotation)
        if (pkgId) {
          return true
        }
        return false
      },

      /**
       * Compute if number of selected channels is all channels
       * @param {Number} selectedChannels
       * @param {Number} channelsLength
       * @returns {Boolean}
       */
      _closeModal: function() {
        this.set('opened', false);
        this.set('canceled', true);
      },

      /**
       * Compute if number of selected channels is all channels
       * @param {Number} selectedChannels
       * @param {Number} channelsLength
       * @returns {Boolean}
       */
       _computeAllChannelsSelected(selectedChannels, channelsLength) {
        return selectedChannels === channelsLength || selectedChannels === 0;
      },

      /**
       * Compute number of selected channels
       * @param {Object} channels
       * @returns {Number}
       */
      _computeSelectedChannels(channels) {
        if (!channels.base) {
          return 0;
        }
        return channels.base.reduce((accum, channel) => {
          if (channel.selected) {
            accum += 1;
          }
          return accum;
        }, 0)
      },

      /**
       * Compute if the user has entered a description
       * @param {String} description
       * @returns {Boolean}
       */
      _computeHasDescription: function(description) {
        if (description) {
          this.set('isFormValid', true)
        }
        return Boolean(description);
      },

      /**
       * Compute heading
       * @param {Boolean} isCreating
       * @returns {String}
       */
       _computeHeading: function(isCreating) {
         return this.isCreating ? 'Create Annotation' : 'Edit Annotation';
      },

      /**
       * Compute button text
       * @param {Boolean} isCreating
       * @returns {String}
       */
      _computeButton: function(isCreating) {
        return this.isCreating ? 'Create Annotation' : 'Save Annotation';
      },

      /**
       * Compute layers for select menu
       * @param {Array} layers
       * @returns {Array}
       */
      _computeLayers: function(layers) {
        if (layers && Array.isArray(layers.base)) {
          return layers.base.map((layer) => {
            return {
              label: layer.name,
              value: layer.id,
              color: layer.color
            }
          });
        }
      },

      /**
       * Compute labels for select menu
       * @param {Array} labels
       * @returns {Array}
       */
      _computeLabels: function(labels) {
        return labels.map((lab) => {
            return {
              label: lab,
              value: lab
            }
          });
      },

      /**
       * Get color from array for layer by ID
       * @param {int} selectedLayerId
       * @param {Array} data
       * @returns {String}
       */
      getColor: (selectedLayerId, data) => R.compose(
        R.propOr('', 'color'),
        R.find(R.propEq('id', selectedLayerId))
      )(data),

      /**
       * Compute color for the selected layer
       * @param {int} selectedLayerId
       * @param {Object} layers
       * @returns {String}
       */
      _computeLayerColor: function(selectedLayerId, layers) {
        if(selectedLayerId) {
          const base = R.propOr([], 'base')(layers);
          return this.getColor(selectedLayerId, base);
        }
      },

      /**
       * Fire event to create annotation
       * @param {Object} e
       */
      submitForm: function(e) {
        if (this.processing) {
          return
        }

        if (!this._hasDescription) {
          this.set('isFormValid', false)
          return
        }

        this.set('processing', true);

        const annotationInfo = {
          description: this.description,
          label: this.selectedLabelId,
          id: this.annotation.id,
          layer_id: this.selectedLayerId,
        };

        if (!this.annotation.layer_id !== this.selectedLayerId) {
          this.fire('get-old-layer', this.annotation.layer_id)
        }

        if (this.hasAnnPackage) {
          annotationInfo.linkedPackage = this.annotation.linkedPackage
          annotationInfo.linkedPackageDTO = this.annotation.linkedPackageDTO
        }

        const annotation = Object.assign({}, this.annotation, annotationInfo);

        if (this.attachPackage) {
          this.fire('open-select-package-window', annotation)
        } else {
          this.fire('edit-annotation', annotation);
          this.set('confirmed', true)
          this.set('canceled', false)
        }
      },

      /**
       * Callback when opening the dialog
       * Focus on first input
       */
      _onOpen: function(evt) {
        if (this.isCreating) {
          this.$.layerSelect.set('selectedValue', this._layers[0].value);
          this.$.labelSelect.set('selectedValue', this._labels[0].value);
        } else {
          this.set('description', this.annotation.description);
        }
        this.$$('bf-textarea').focus();
      },

      /**
       * Callback when closing the dialog
       * Reset the properties
       * @param (Object) Event
       * @param {Object} detail
       */
      _onClose: function(e, detail) {
        if (this.isCreating && this.canceled && !this.processing) {
          this.fire('confirmed-delete-annotation', {
            annotation: this.annotation,
            toast: false
          });
        } else if (this.isCreating && this.attachPackage) {
          this.set('processing', false);
          return
        }

        this.reset()
      },

      /**
       * Handle TS Annotation Reset
       */
      reset: function() {
        const attachPkg = Polymer.dom(this.root).querySelector('.attach-package')
        if (attachPkg) {
          attachPkg.checked = false
        }
        this.set('layers', [])
        this.set('attachPackage', false)
        this.set('annotation', {});
        this.set('label', '');
        this.set('description', '');
        this.set('id', '');
        this.set('processing', false);
        this.set('isFormValid', true)
      },

      /**
      * Handle remove attachment event
      * @param {Object} e
      */
      removeAttachment: function(e) {
        const annotation = R.clone(this.annotation)
        delete annotation.linkedPackage
        delete annotation.linkedPackageDTO
        this.annotation = {}
        this.annotation = annotation
      },
      /**
       * Handle Attach Package click event
       * @param {Object} e
       */
      onAttachPackage: function(e) {
        this.attachPackage = e.target.checked
      }
    });

  </script>
</dom-module>
