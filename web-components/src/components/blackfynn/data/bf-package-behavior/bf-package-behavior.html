<link rel="import" href="../../../../../bower_components/polymer/polymer.html">

<link rel="import" href="../../../../vendor-scripts.html">
<script>
  window.Blackfynn = window.Blackfynn || {};
  /**
  * @polymerBehavior
  */

  Blackfynn.DataPackageBehavior = {
    properties: {
      isAuto: {
        type: Boolean,
        value: false
      },
      packages: {
        type: Array,
        value: undefined
      },
      _packages: {
        type: Array,
        value: function() {
          return [];
        }
      },
      curPackage: {
        type: Object,
        value: {
          content: {},
          parent: '',
          properties: [],
          children: []
        },
        notify: true
      },
      moveItemUrl: {
        type: String,
        computed: '_computeMoveItemUrl(state.apiUrl, state.userToken)'
      },
      /**
      * Property for sorting
      */
      sortBy: {
        type: String,
        value: null
      },
      /**
      * Direction for sorting
      */
      sortDirection: {
        type: String,
        value: null
      },
      /**
      * Icon showing sort direction
      */
      sortIcon: {
        type: String,
        computed: '_computeSortIcon(sortDirection)'
      },
      /**
       * Array of all items selected by the user
       */
      selected: {
        type: Array,
        value: function() {
          return [];
        },
        notify: true
      },
      /**
       * Last selected item in the list. Used for shift+click selection
       */
      lastSelectedItem: {
        type: Object,
        value: function() {
          return {};
        }
      },
      /**
       * Show or hide the drag info
       */
      dragInfoHidden: {
        type: Boolean,
        value: true
      },
      /**
       * Name to show in the drag info
       */
      dragName: {
        type: String
      },
      /**
       * Bound to the `iron-ajax` component to get collection data
       */
      isLoadingCollection: {
        type: Boolean,
        value: false
      },
      /**
       * Tracks when collection data is loading or search is being performed
       */
      isLoading: {
        type: Boolean,
        computed: '_isLoading(isLoadingCollection, state.isLoadingSearch)'
      },
      /**
       * Used when there are no children in curPackage to display
       */
      isEmpty: {
        type: Boolean,
        computed: '_computeIsEmpty(packages.length)',
        value: false
      },
      _getCollectionDataUrl: {
        type: String,
        computed: '_computeGetCollectionDataUrl(state.apiUrl, state.userToken, catalogRouteData.id)'
      },
      /**
       * Sets styles and limits functionality to only collections for data-items
       */
      collectionsOnly: {
        type: Boolean,
        value: false
      },
      /**
       * Allow users to select multiple items
       */
      multiSelectItems: {
        type: Boolean,
        value: true
      },
      /**
       * Opens the create collection dialog
       */
      createCollectionOpen: {
        type: Boolean,
        value: false
      },
      /**
       * Stores the move item payload in the event of conflicts
       */
      movePayload: {
        type: Object,
        value: function() {
          return {};
        }
      }
    },

    listeners: {
      'select-item': 'selectItem',
      'start-drag-item': 'startDragItem',
      'move-item': 'moveItem',
      'add-collection': 'addCollection',
      'open-collection': 'openCollection'
    },

    /**
    * Updates viewType property value
    * @param {Event} evt
    */
    updateViewType: function(evt) {
      const newViewType = R.pathOr('list', ['target', 'value'], evt);
      this.set('viewType', newViewType);
    },

    /**
    * Computes when collection is being fetched or search is being performed
    * @param {Boolean} isLoadingCollection
    * @param {Boolean} isLoadingSearch
    * @returns {Boolean}
    */
    _isLoading(isLoadingCollection, isLoadingSearch) {
      return isLoadingCollection || isLoadingSearch;
    },

    /**
    * Compute the sort icon based on sort direction
    */
    _computeSortIcon: function(sortDirection) {
      if(sortDirection === 'ASC') {
        return 'blackfynn:number-input-up';
      } else if(sortDirection === 'DESC') {
        return 'blackfynn:number-input-down';
      }
    },

    openCollection: function(e, detail) {
      this.fire('set-state-path', {
        path: 'isSearching',
        state: false
      });

      // Don't get new collection data if user requests same folder as current
      if(detail.triggerLoad === false && this.curPackage.content.id === detail.data.id) {
        return;
      }
      // Set the route to the new collection's id as long as no modals are open
      const dataId = R.pathOr('', ['data', 'id'], detail);

      const catalogRoute = Boolean(dataId) ? `/${dataId}` : '';
      this.set('catalogRoute.path', catalogRoute);

      // Reset selected list
      this.set('selected', []);
    },

    _getNodeType: function(id, nodeTypes) {
      if (!id) {
        return 'datasets';
      }
      for (let i = 0; i < nodeTypes.length; i++) {
        if(id.toLowerCase().indexOf(nodeTypes[i].toLowerCase()) > 0) {
          return nodeTypes[i]
        }
      }

      return 'datasets';
    },

    _computeGetCollectionDataUrl: function(api, user, id) {
      const baseUrl = id && id.indexOf('dataset') < 0 ? 'packages' : 'datasets';
      return `${api}/${baseUrl}/${id}?api_key=${user}&includeAncestors=true`;
    },

    _computeMoveItemUrl: function(api, user) {
      return `${api}/data/move?api_key=${user}`;
    },

    _computeIsEmpty: function(packagesLength) {
      return packagesLength === 0;
    },

    _computeDisplayHeaders: function(isEmpty, hideHeadings) {
      return isEmpty || hideHeadings;
    },

    _handleGetCollectionData: function(e, detail) {
      let packages = [];

      const responseData = detail.response.children ? detail.response.children : detail.response;

      for (let i = 0; i < responseData.length; i++) {
        packages.push(responseData[i]);
      }

      this.set('selected', []);
      this.set('packages', packages);
      this.set('curPackage', detail.response);
      // Set breadcrumbs
      this.fire('set-breadcrumbs', { ancestors: detail.response.ancestors });
    },

    setSearchResults: function(data) {
      // Save existing data to show when the user cancels searching
      if(this._packages && this._packages.length === 0) {
        this.set('_packages', this.packages);
      }
      // Set new data
      this.set('packages', data);
    },

    revertSearchResults: function() {
      // Revert data to packages before search
      this.set('packages', this._packages);
      this.set('_packages', []);
      this.set('curPackage', { content: {} });
    },

    removeItems: function(items) {
      for (let i = 0; i < items.length; i++) {
        const index = this.packages.indexOf(items[i].data);

        // Remove the item
        if(index !== -1) {
          this.splice('packages', index, 1);
        }
      }
    },

    selectItem: function(e, detail) {
      const indexOfItem = this.selected.indexOf(detail.item);

      // Shift click will select all of the items from last current selected to clicked item
      if(detail.shiftKey) {
        if(this.selected.length > 0) {

          const items = Polymer.dom(this.root).querySelectorAll('bf-data-item');
          const lastItemIndex = this.lastSelectedItem.index;

          let firstIndex = detail.item.index;
          let lastIndex = lastItemIndex;

          if(lastItemIndex < firstIndex) {
            firstIndex = lastItemIndex;
            lastIndex = detail.item.index + 1;
          } else {
            lastIndex = lastIndex + 1;
          }

          const newItems = items.slice(firstIndex, lastIndex);

          this.set('selected', newItems);
        }
        return;
      }

      // Check if the item is already selected
      if(indexOfItem === -1) {
        if(detail.metaKey) {
          // Add item to selected list
          this.push('selected', detail.item);
        } else {
          // Reset selected list and only have this item selected
          this.set('selected', [detail.item]);
        }

        this.set('lastSelectedItem', detail.item);

      } else {
        // Unset selected
        if(detail.metaKey) {
          this.splice('selected', indexOfItem, 1);
        } else {
          this.set('selected', []);
        }
      }

      this.fire('items-selected', this.selected);
    },

    startDragItem: function(e, detail) {
      // Set drag info name
      this.set('dragName', detail.name);

      // Show the drag info
      this.set('dragInfoHidden', false);
      this.fire('set-move-item', {e, item: this.selected});

      // Set drag image
      detail.e.dataTransfer.setDragImage(this.$.dragInfo, 0, 0);
    },

    endDragItem: function(e, detail) {
      this.set('dragInfoHidden', true);
    },

    /**
     * Called when an element has moved to a different element
     *
     */
    moveItem: function(e) {
      // Remove selections
      this.set('selected', []);

      const items = R.pathOr([], ['detail', 'items'], e);
      const things = R.flatten(
        R.map(R.pathOr([], ['data', 'content', 'id']), items)
      );
      // Get the iron-ajax component
      const ajaxRequest = this.$.moveItem;
      const payload = {
        destination: e.detail.destination,
        things: things.length > 0 ? things : items
      };
      ajaxRequest.body = payload;

      // Generate the request
      ajaxRequest.generateRequest();
    },

    _handleMoveItem: function(e, detail) {
      this.fire('finished-move');

      if (detail.response && detail.status === 200) {
        // Get the destination
        const destinationIndex = this.getIndexById(detail.response.destination, this.packages);
        const destinationName = R.defaultTo('Dataset', this.get(`packages.${destinationIndex}.content.name`));
        const successLength = detail.response.success.length;

        // Success items
        for (let i = 0; i < successLength; i++) {
          // Get path of item to move
          const itemIndex = this.getIndexById(detail.response.success[i], this.packages);

          // Remove the item
          this.splice('packages', itemIndex, 1);
        }

        let itemMsg = 'item';

        if(successLength > 1) {
          itemMsg = 'items'
        }

        // Failure items
        const errors = R.pathOr([], ['response', 'failures'], detail);
        if (errors.length > 0) {
          this.fire('save-conflicts-payload', {
            destination: detail.response.destination,
            things: R.pluck('id', detail.response.failures)
          });
        }
        errors.forEach(error => {
          // Get path of item
          const itemIndex = this.getIndexById(error.id, this.packages);
          this.set(`packages.${itemIndex}.hasError`, true);
        });

        // handle name conflicts
        const nameConflicts = R.defaultTo([], R.pluck('generatedName')(errors));
        if (nameConflicts.length > 0) {
          this.fire('display-move-conflicts', detail.response);
        }

        if (errors.length > 0 && nameConflicts.length === 0) {
          this.fire('toast', {type: 'ERROR'});
        }

        if(successLength > 0) {
          if (errors.length === 0) {
            this.fire('close-move-dialog');
          }
          this.fire('toast', { type: 'MESSAGE', msg: `${successLength} ${itemMsg} moved to "${destinationName}"`});
        }
      } else {
        this.fire('toast', {type: 'ERROR'});
      }

    },

    getIndexById: function(id, data) {
      for (let i = 0; i < data.length; i++) {
        if(data[i].content.id === id) {
          return i;
        }
      }

      return false;
    },

    openCollectionDialog: function(selectedItem) {
      this.set('selected', selectedItem)
      this.set('createCollectionOpen', true);
    },

    addCollection: function(e, detail) {
      this.push('packages', detail.item);
    },

    /**
    * Sort the package list
    */
    setSort: function(e) {
      const sortBy = this.get('sortBy');
      const newSortBy = e.target.getAttribute('sort-method');
      const sortDirection = this.get('sortDirection');

      // Set sort direction
      if(sortBy !== newSortBy || sortDirection === null) {
        this.set('sortDirection', 'ASC')
      } else if(sortDirection === 'ASC') {
        this.set('sortDirection', 'DESC')
      } else {
        this.set('sortDirection', null)
        this.set('sortBy', null);
        return;
      }

      this.set('sortBy', newSortBy);
    },

    /**
    * Compute if the package list is sorted by given column
    */
    _isSorting: function(sortBy, name) {
      return sortBy === name;
    },

    /**
    * Compute sort method for list
    */
    _sort: function(sortBy, sortDirection) {
      switch(sortBy) {
        case 'name':
          return (a, b) => {
            if (a.content.name === b.content.name) return 0;

            if(sortDirection === 'ASC') {
              return a.content.name < b.content.name ? -1 : 1;
            } else if(sortDirection === 'DESC') {
              return a.content.name > b.content.name ? -1 : 1;
            }

            return 0;
          };
        case 'type':
          return (a, b) => {
            if (a.content.packageType === b.content.packageType) return 0;

            if(sortDirection === 'ASC') {
              return a.content.packageType < b.content.packageType ? -1 : 1;
            } else if(sortDirection === 'DESC') {
              return a.content.packageType > b.content.packageType ? -1 : 1;
            }

            return 0;
          };

        case 'created':
          return (a, b) => {
            const aCreated = this.getCreatedDate(a.properties).value;
            const bCreated = this.getCreatedDate(b.properties).value;

            if (aCreated === bCreated) return 0;

            if(sortDirection === 'ASC') {
              return aCreated < bCreated ? -1 : 1;
            } else if(sortDirection === 'DESC') {
              return aCreated > bCreated ? -1 : 1;
            }

            return 0;
          };
      }
    }
  }
</script>
